# 11장
# 뉴스 피드 시스템 설계

## 피드 발행 흐름 상세 설계

### 웹 서버

- 클라이언트와 통신 뿐만 아니라 인증, 처리율 제한등의 기능도 수행, 올바른 인증토큰을 헤더에 담고 API를 호출하는 사용자만 포스팅 가능해야함, 또한 스팸, 유해한 콘텐츠가 자주 올라오는 것을 방지하기 위해서 특정 기간 동안 한 사용자가 올릴 수 있는 포스팅의 수에 제한을 두어야 한다.

### 포스팅 전송(팬아웃)  서비스

- 팬아웃은 어떤 사용자의 새 포스팅을 그 사용자와 친구 관계에 있는 모든 사용자에게 전달하는 과정, 팬 아웃에는 2가지 모델이 있는데 하나는 쓰기 시점에 팬아웃 하는 모델이고 하나는 읽기 시점에 팬아웃 하는 모델이다.
1. 쓰기 시점에 팬아웃 하는 모델 : 새로운 포스팅을 기록하는 시점에 뉴스 피드를 갱신, 포스팅이 완료되면 바로 해당 사용자의 캐시에 해당 포스팅을 기록하는 것이다.
2. 읽기 시점에 팬아웃 하는 모델 : 피드를 읽어야 하는 시점에 뉴스 피드를 갱신한다. 사용자가 본인 홈페이지나 타임라인을 로딩하는 시점에 새로운 포스트를 가져오게 된다.

### 쓰기, 읽기 시점에 팬아웃 동작 흐름

1. 그래프 DB에서 친구 ID 목록을 가져온다.
2. 사용자 정보 캐시에서 친구들의 정보를 가져온다. 이후에 사용자 설정에 따라 친구 가운데 일부를 걸러낸다.
3. 친구 목록과 새 스토리의 포스팅 ID를 메시지 큐에 넣는다.
4. 팬아웃 작업 서버는 메시지 큐에서 데이터를 꺼내서 뉴스 피드 데이터를 뉴스 피드 캐시에 넣는다. 해당 데이터는 <post_id, user_id> 방식으로 되어있다.
5. 뉴스 피드에 표시할 사용자 이름, 사용자 사진, 포스팅 콘텐츠, 이미지 등을 사용자 캐시와 ㅍ포스팅 캐시에서 가져와 완전한 뉴스 피드를 만든다.
6. 생성된 뉴스 피드를 JSON 형태로 클라이언트에게 보낸다.

### 캐시 구조

- 뉴스 피드 : 뉴스 피드의 ID를 보관한다.
- 콘텐츠 : 포스팅 데이터를 보관한다. 인기 콘텐츠는 따로 보관한다.
- 소셜 그래프 : 사용자 간 관계 정보를 보관한다.
- 행동 : 포스팅에 대한 사용자의 행위에 관한 정보를 보관한다. 포스팅에 대한 ‘좋아요’, ‘답글’ 등등이 이에 해당한다.
- 횟수 : 좋아요 횟수, 응답 수, 팔로어 수, 팔로잉 수 등의 정보를 보관한다.

### 추가적으로 다루면 좋은 내용

- DB 확장
    - 스케일 업 vs 스케일 아웃
    - SQL vs NoSQL
    - master-salve 다중화
    - 복제본 에 대한 읽기 연산
    - 일관성 모델
    - DB 샤딩

--------

# 12장

# 채팅 시스템

# 통신 프로토콜

- http : 웹에서 가장 널리 사용되는 프로토콜이며, 메시지 전송 용도로 괜찮은 선택이다. 하지만 메시지 수신 시나리오는 더 복잡하며 HTTP는 클라이언트가 연결을 만드는 프로토콜이고 서버에서 클라이언트로 임의 시점에 메시지를 보내는 데는 쉽게 쓰일 수 없다.
- 폴링 : 클라이언트가 주기적으로 서버에게 새 메시지가 있냐고 물어보는 방법이다. 폴링을 자주 할수록 비용이 올라가며 답해줄 메시지가 없는 경우에는 서버자원이 불필요하게 낭비된다.

![](https://velog.velcdn.com/images/ohdowon064/post/a0f620b4-000f-45ea-a102-176c15d55241/image.png)

- 롱 폴링 : 클라이언트는 새 메시지가 반환되거나 타임아웃 될 때까지 연결을 유지한다. 클라이언트는 새 메시지를 받으면 기존 연결을 종료하고 서버에 새로운 요청을 보내어 모든 절차를 다시 시작한다.

![](https://velog.velcdn.com/images/ohdowon064/post/0c47849e-5aeb-42ea-89cf-aea442d04340/image.png)

- 웹 소켓 : 클라이언트에게 비동기 메시지를 보낼 때 가장 널리 사용하는 기술이다. 웹소켓의 연결은 클라이언트가 시작하며 한번 맺어진 연결은 항구적이고 양방향이다. 처음은 HTTP 연결이지만 특정 핸드셰이크 절차를 거쳐 웹소켓 연결로 업그레이드된다.

![](https://velog.velcdn.com/images/ohdowon064/post/bd27d8c8-6b33-48be-8b54-6abca899d665/image.png)

![](https://velog.velcdn.com/images/ohdowon064/post/b58345e2-dcf3-42d1-b6d3-f63cc12a0330/image.png)

- 무상태 서비스 : 로그인, 회원가입, 사용자 프로필 등을 표시하는 전통적인 요청/응답 서비스다. 무상태 서비스는 로드밸런서 뒤에 위치하며 해당 서비스는 모놀리식 일수도, 마이크로서비스일 수도 있다.
- 상태유지 서비스 : 클라이언트는 보통 서버가 살아 있는 한 다른 서버로 연결을 변경하지 않는다. 앞서 간단히 설명한 서비스 탐색 서비스는 채팅 서비스와 긴밀히 협력하여 특정 서버에 부하가 몰리지 않도록 한다.
- 제3자 서비스 연동 : 채팅 앱에서 가장 중요한 제3자 서비스는 푸시 알림이다. 새 메시지를 받았다면 설사 앱이 실행 중이지 않더라도 알림을 받아야한다.
  - 규모 확장성 : 트래픽 규모가 작을땐 모든 기능을 서버 한 대로 구현할 수 있다. 동시 접속자가 100만명이라도 접속당 10K의 서버 메모리가 필요하다면 10GB의 메모리로 모든 연결을 처리할 수 있다. 하지만SPOF 같은 문제때문에  면접에선 좋은 점수를 따지 못 할 것이다.
  - 저장소 : 데이터 계층을 올바르게 만드는데 노력이 필요하다. 채팅 시스템이 다루는 데이터는 보통 두 가지다. 첫 번짼 사용자 프로파일, 설정, 친구 목록처럼 일반적인 데이터, 두번째론 채팅 시스템에 고유한 데이터로 채팅 이력이다. 많은 데이터, 무작위 데이터 접근 등을 지원해야 한다.

## 데이터 모델

- 1:1 채팅을 위한 메시지 테이블 : created_at 같은 생성 시간은 메시지 순서를 정할 수 없다, 서로 다른 두 메시지가 동시에 만들어질 수도 있기 때문이다. 이 테이블의 기본키는 message_id 이며 메시지 순서를 쉽게 정할 수 있는 역할도 담당한다.
- 그룹 채팅을 위한 메시지 테이블 : channel_id, message_id의 복합키를 기본 키로 사용한다. 여기서 채널은 채팅 그룹과 같은 뜻이고 channel_id 는 파티션 키 로도 사용한다.

### 메시지 ID

- message_id는 순서를 표현할 수 있으며, 고유해야한다. 그리고 정렬을 했을때 시간 순서와 일치해야 한다. RDBMS라면 AUTO_INCREMENT 기능을 지원하겠지만 NoSQL은 보통 해당 기능을 제공하지않는다. 두번째 방벙은 스노플레이크 같은 전역적 ID 생성기를 이용하는 것이다. 마지막 방법은 지역적 순서 번호 생성기를 이용하는 것인데, 여기서 지역은 ID의 유일성은 같은 그룹 안에서만 보증하면 충분하다. 이 방법이 통하는 이유는 메시지 사이의 순서는 같은 채널, 혹은 1:1채팅 내에서만 유지되면 충분하기 떄문이다.

## 상세 설계

### 서비스 탐색

- 서비스 탐색 기능의 주된 역할은 클라이언트에게 가장 적합한 채팅 서버를 추천해주는 것이다. 이때 사용되는 기준은 클라이언트의 위치, 서버의 용량 등이 있다. 서비스 탐색 기능을 구현하는데 가장 널리 쓰이는 오픈소스 솔루션은 아파치 주키퍼 같은 것이 있다.

### 메시지 흐름

- 1:1 채팅 메시지 처리 흐름 
![](https://velog.velcdn.com/images/ohdowon064/post/b2ffd01b-5ac8-4131-b806-02729774546c/image.png)

  1. 사용자 A가 채팅 서버1로 메시지 전송
  2. 채팅 서버1은 ID 생성기로 ID값 생성
  3. 채팅 서버1은 해당 메시지를 메시지 동기화 큐로 전송
  4. 메시지가 키-값 저장소에 저장됨
  5. 사용자 B가 접속중인 경우 메시지는 사용자 B가 접속주인 채팅서버 2로 전송됨, 접속중이 아니라면 푸시 알림 메시지를 푸시 알림 서버로 보냄
  6. 채팅 서버2는 메시지를 사용자 B에게 전송. 사용자 B와 채팅서버 2는 웹소켓 연결 되어있는 상태이므로 그것을 이용

- 여러 단말 사이의 메시지 동기화
![](https://velog.velcdn.com/images/ohdowon064/post/2f48cd75-399f-4107-b54d-281be22e9e4f/image.png)
  - 사용자 A는 전화기와 랩톱 두 대의 단말을 이용하고 있다.
  - 이는 웹소켓 연결이 되어있고 랩톱 역시 별도 웹소켓이 채팅서버에 연결되어있다.
  - 각 단말은 cur_max_message_id 라는 변수를 유지하는데, 해당 단말에서 관측된 가장 최신 메시지의 ID를 추적하는 용도다. 아래 두 조건을 만족하는 메시지는 새 메시지로 간주한다.
    - 수신자 ID가 현재 로그인한 사용자 ID와 같다.
    - 키-값 저장소에 보관된 메시지로서, 그 ID가 cur_max_message_id 보다 크다

- 소규모 그룹 채팅에서의 메시지 흐름
![](https://velog.velcdn.com/images/ohdowon064/post/fe46cfee-7417-467c-9801-8c9bf7cf6308/image.png)
    - 소규모 그룹 채팅은 사용자 A가 보낸 메시지가 메시지 동기화 큐에 복사된다. 해당 메시지 동기화 큐는 수신함 같은 것으로 생각해도 무방하다. 이 설계안은 소규모 그룹 채팅에 적합하다.
    - 새로운 메시지가 왔는지 확인하려면 자기 큐만 보면 되니까 메시지 동기화 플로가 단순하다.
    - 그룹이 크지 않으면 메시지를 수신자별로 복사해서 큐에 넣는 작업의 비용이 문제가 되지 않는다.

### 접속상태 표시

- 사용자의 접속 상태를 표시하는 것은 상당수 채팅 어플리케이션의 핵심적 기능이다.
  - 사용자 로그인 : 클라이언트와 실시간 서비스사이에 웹소켓 연결이 맺어지면 서비스 A의 상태와 last_active_at 타임스탬프 값을 키-값 저장소에 보관한다.
  - 로그아웃 : 사용자 로그아웃은 키-값 저장소에 보관된 사용자 상태가 online 에서 offline으로 바뀌게 된다.
  - 접속장애 : 사용자의 인터넷 연결이 끊어지면 클라이언트와 서버간의 웹소켓 연결도 끊어진다. 가장 간단하게 해결하는 방법은 사용자를 오프라인상태로 표시하고 연결이 복구되면 온라인 상태로 변경하는것이다. 하지만 이 방법은 너무 많은 상태 업데이트를 변경한다면 UX나 서버 입장에서도 바람직하지 않을 것이다. 이런 상황은 heartbeat 구현으로 해결 할 수 있다.
  - 상태 정보의 전송 : 각각의 친구 관계마다 채널을 하나씩 두고 상태가 업데이트 될때 각각의 채널에서 구독하고 통지를 받는다. 클라이언트와 서버의 통신은 웹소켓을 사용한다. 이 방안은 그룹 크기가 작을 때 효과적이다. 그룹크기가 클 때에는 성능문제가 발생하는데 그룹 채팅에 입장할때만 상태정보를 읽어가게 하거나, 친구 리스테에 있는 사용자의 접속상태를 갱신하고 싶으면 수동으로 변경하도록 유도하는것이다.