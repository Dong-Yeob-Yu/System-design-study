# 11장 뉴스 피드 시스템 설계
## 문제 이해 및 설계 범위 확정
* 모바일 앱, 웹 둘 다 지원해야 함
* 뉴스 피드 페이지에 새로운 스토리를 올리 수 있어야 하고, 친구들이 올리는 스토리를 볼 수 도 있어야 함
* 시간 역순 표시
* 한 사용자는 최대 5000명의 친구를 가질 수 있다.
* 매일 천만 명이 방문
* 스토리에 이미지, 비디오 등의 미디어 파일 업로드 가능
## 개략적 설계안 제시
* 피드 발생
  * 사용자가 스토리를 포스팅하면 해당 데이터를 캐시와 데이터베이스에 기록한다.
  * 새 포스팅은 친구의 뉴스 피드에도 전송된다.
* 뉴스 피드 생성
  * 지면 관계상 뉴스 피드는 모든 친구의 포스팅을 시간 흐름 역순으로 모아서 만든다.
### 뉴스 피드 API
#### 피드 발행 API
> POST /v1/me/feed

> GET /v1/me/feed
* Authorization 헤더: API 호출을 인증하기 위해 사용한다.

### 피드 발행
* 포스팅 저장 서비스: 새 포스팅을 DB와 cache에 저장
* 포스팅 전송 서비스: 새 포스팅을 친구의 뉴스 피드에 push
* 알림 서비스: 친구들에게 새 포스팅이 올라왔음을 알리거나, 푸시 알림을 보내는 역할
### 뉴스 피드 생성
* 뉴스 피드 서비스: 캐시에서 뉴스 피드를 가져오는 서비스
* 뉴스 피드 캐시: 뉴스 피드를 렌더링할 때 필요한 피드 ID를 보관한다.

## 상세 설계
### 피드 발행 흐름 상세 설계
#### 웹 서버
* Authorization 헤더를 통한 인증
* 스팸을 막고 유해한 코텐츠가 올라는 것을 방지하기 위한 처리율 제한

#### 포스팅 전송(fan-out) 서비스
* fanout: 어떤 사용자의 새 포스팅을 그 사용자와 친구 관계에 있는 모든 사용자에게 전달하는 과정
  * 대부분의 사용자의 경우 뉴스 피드를 빠르게 가져올 수 있도록 푸시 모델을 사용하고
  * 팔로어가 아주 많은 사용자의 경우에는 풀 모델을 사용하여 시스템 과부하를 방지 
##### 쓰기 시점 팬아웃(fanout-on-write / push)
* 새로운 포스팅을 기록하는 시점에 뉴스 피드를 갱신 -> 포스팅이 완료되면 바로 해당 사용자 캐시에 기록
* 장점
  * 뉴스 피드가 실시간으로 갱신되며 친구 목록에 있는 사용자에게 즉시 전송
  * 새 포스팅이 기록되는 순간에 슈스 피드가 갱신되므로 피드를 읽는데까지 지연이 짧아짐
* 단점
  * 친구가 많은 사용자의 경우 친구 목록을 가져오고 그 목록에 있는 사용자 모두의 뉴스 피드를 갱신하는데 많은 시간이 소요될 수 있다. (hotkey 혹은 hotspot 문제)
  * 서비스를 자주 이용하지 않는 사용자의 피드까지 갱신해야 되므로 컴퓨팅 자원이 낭비된다.

##### 읽기 시점 팬아웃(fanout-on-read / pull)
* 피드를 읽어야 하는 시점에 뉴스 피드를 갱신한다. 요청 기반(on-demand) 모델
* 장점
  * 비활성화된 사용자, 또는 서비스에 거의 로그인하지 않는 사용자의 경우에는 이 모델이 유리하다.
  * 데이터를 친구 각각에 푸시하는 작업이 필요 없으므로 핫키 문제도 생기지 않는다.
* 단점
  * 뉴스 피드를 읽는 데 많은 시간이 소요될 수 있다.

##### 포스팅 전송 서비스 구현
1. 그래프 데이터베이스(Neo4j같은)에서 친구 ID 목록을 가져온다.
2. 사용자 정보 캐시에서 친구들의 정보를 가져온다. 그런 후에 사용자 설정에 따라 친구 가운데 일부를 걸러낸다.
   * 예를 들어 차단한 사용자
3. 친구 목록과 새 스토리의 포스팅 ID를 메시지 큐에 넣는다.
4. 팬아웃 작업 서버가 메시지 큐에서 데이터를 꺼내어 뉴스 피드 데이터를 뉴스 피드 캐시에 넣는다.
   * 뉴스 피드 캐시는 <포스팅 ID, 사용자 ID> 순서쌍을 보관하는 매핑 테이블이라고 불 수 있다.
   * 어떤 사용자가 뉴스 피드에 올라온 수 천 개의 스토리를 전부 훑어보는 일이 거의 없기 때문에 캐스 미스가 발생할 확률은 매우 낮다.

### 피드 읽기 흐름 상세 설계
1. 사용자가 뉴스 피드를 읽으려는 요청을 보낸다.
2. 로드밸런서가 요청을 웹 서버 가운데 하나로 보낸다.
3. 웹 서버는 피드를 가져오기 위해 뉴스 피드 서비스를 호출한다.
4. 뉴스 피드 서비스는 뉴스 피드 캐시에서 포스팅 ID 목록을 가져온다.
5. 뉴스 피드에 표시할 사용자 이름, 사용자 사진, 포스팅 콘텐츠, 이미지 등을 사용자 캐시와 포스팅 캐시에서 가져와 완전한 뉴스 피드를 만든다.
6. 생성된 뉴스 피드를 JSON 형태로 클라이언트에 보낸다. 클라이언트는 해당 피드를 렌더링한다.
#### 캐시 구조
* 총 다섯 계층으로 캐시를 보관
  * 뉴스 피드: 뉴스 피드의 ID를 보관
  * 콘텐츠: 일반 포스팅 데이터 / 인기 콘텐츠를 따로 보관
  * 소셜 그래프: 사용자 간의 관계 정보를 보관
  * 행동: 포스팅에 대한 사용자의 행위에 대한 정보를 보관(좋아요, 답글 등)
  * 횟수: 좋아요 횟수, 응답 수, 팔로어 수, 팔로잉 수 등의 정보 보관
## 마무리
### 데이터베이스 규모 확장
* 수직적 규모 확장 vs 수평적 규모 확장
* SQL vs NoSQL
* master-slave 다중화
* 복제본에 대한 읽기 연산
* 일관성 모델
* 데이터베이스 샤딩
### 그 밖에 논의해볼 점
* 웹 계층 무상태로 운영
* 가능한 한 많은 데이터를 캐시할 방법
* 여러 데이터 센터를 지원할 방법
* 메시지 큐를 사용하여 컴포넌트 사이의 결합도 낮추기
* 핵심 메트릭에 대한 모니터링. 트래픽 몰리는 시간대의 QPS, 사용자가 뉴스 피드를 새로고침 할 때의 지연 시간 등

# 12장 채팅 시스템 설계
## 문제 이해 및 설계 범위 확정
* 1:1 채팅, 그룹 채팅 둘 다 지원
* 모바일 앱, 웹 전부 지원
* 일별 능동 사용자 수 5천만
* 그룹 채팅의 경우 100까지 참가 가능
* 1:1 채팅, 그룹 채팅, 사용자 접속 상태 표시 지원
* 100,000자 이하의 메시지를 주고 받을 수 있음
* 추후 종단 간 암호화 지원 필요할 수 있음
* 채팅 이력 영구 보존
* 하나의 계정으로 여러 단말에 동시 접속 지원
* 푸시 알림

## 개략적 설계안
* 클라이언트는 TCP hand-shake를 줄이기 위해 keep-alive 헤더를 사용하면 효율적이다.
### 메시지 수신 기법
#### polling
* 클라이언트가 서버에 주기적으로 새 메시지를 조회하는 방법
* 답해줄 메시지가 없는 경우에는 서버 자원이 불필요하게 낭비된다.
#### long polling
* 클라이언트는 새 메시지가 반환되거나 타임아웃 될 떄까지 연결을 유지한다.
* 메시지를 보내는 클라이언트와 수신하는 클라이언트가 같은 채팅 서버에 접속하게 되지 않을 수 있다.
* 서버 입장에서는 클라이언트가 연결을 해제했는지 아닌지 알 효율적인 방법이 없다.
* 메시지를 많이 받지 않는 클라이언트도 타임아웃이 일어날 때마다 주기적으로 서버에 다시 접속할 것이라 여전히 비효율적
#### WebSocket
* TCP hand-shake 이후 종료 이전까지 연결이 항구적이며, 양방향 통신을 수행하게 된다.
* 웹소켓 연결은 항구적으로 유지되어야 하기 때문에 서버 측에서 연결 관리를 효율적으로 해야 한다.

### 채팅 시스템 설계안
#### 무상태 서비스
* 로그인, 회원가입, 사용자 프로파일 표시 등을 처리하는 전통적인 요청/응답 서비스
* 서비스 탐색 서비스의 경우 클라이언트가 접속할 채팅 서버의 DNS 호스트명을 알려주는 역할
#### 상태유지 서비스
* 각 클라이언트가 채탱 서버와 독립적인 네트워크 연결을 유지해야 하기 때문에 상태가 유지되어야 함
#### 제3자 서비스 연동
* 푸시 알림과 같은 제3자 서비스는 앱이 실행 중이지 않더라도 알림을 받아 한다.
#### 규모 확장성
* 채팅 서버는 클라이언트 사이에 메시지를 중계하는 역할을 담당한다.
* 접속상태 서버는 사용자의 접속 여부를 관리한다.
* API 서버는 로그인, 회원가입, 프로파일 변경 등 그 외 나머지 전부를 처리한다.
* 알림 서버는 푸시 알림을 보낸다.
* key-value store에는 채팅 이력을 보관한다. 시스템에 접속한 사용자는 이전 채팅 이력을 전부 보게 될 것이다.
#### 저장소
* 채팅 시스템에서 다루는 데이터는 보통 두 가지이다.
  * 사용자 프로파일, 설정, 친구 목록처럼 일반적인 데이터다.
  * 채팅 시스템의 고유한 데이터인 채팅 이력이다.
##### 일반적인 데이터 저장소
* 이런 데이터는 안정성을 보장하기 위해 관계형 DB에 저장한다.
* 다중화나 샤딩은 이런 데이터의 가용성과 규모확장성을 보증하기 위해 보편적으로 사용된다.
##### 채팅 이력 데이터 저장소
* 채팅 이력 데이터의 양은 엄청나다. 빅테크 기업은 매일 60,000,000,000억 개의 메시지를 처리한다.
* 대부분의 사용자는 오래된 메시지를 들여다보지 않는다.
* 사용자는 검색 기능을 이용하거나, 특정 사용자가 언급된 메시지를 보거나, 특정 메시지로 점프하는 경우도 있다.
* 1:1 채팅 앱의 경우 읽기 쓰기 비율은 1:1 정도이다.
* 위 조건들을 충족할 수 있는 DB는 key-value store이다.
##### key-value store
* 수평적 규모 확장이 용이함
* 데이터 접근 지연시간이 낮다.
* 관계형 데이터베이스는 long tail에 해당하는 부분을 잘 처리하지 못하는 경향이 있다. 인덱스가 커지면 데이터에 대한 무작위 접근을 처리하는 비용이 늘어난다.
* 페이스북 메신저는 HBase, 디스코드는 카산드라를 이용하고 있음
#### 데이터 모델
##### 1:1 채팅 메시지
| message      |           |
|--------------|-----------|
| message_id   | bigint    |
| message_from | bigint    |
| message_to   | bigint    |
| content      | text      |
| create_at    | timestamp |
##### 그룹 채팅 메시지
| group message |           |
|---------------|-----------|
| channel_id    | bigint    |
| message_id    | bigint    |
| message_to    | bigint    |
| content       | text      |
| create_at     | timestamp |
* channel_id는 파티션 키로도 사용할 수 있음

##### 메시지 ID
* message_id의 값은 고유해야 한다.
* ID값은 정렬 가능해야 하며 시간 순서와 일치해야 한다.
* auto_increment / 스노플레이크 / 지역적 순서 번호 생성기 등의 기법으로 만들 수 있음

## 상세 설계
### 서비스 탐색
* 클라이언트에게 적합한 채팅 서버를 추천하는 것
* 클라이언트의 위치, 서버의 용량 등이 기준이 될 수 있음
* Apache Zookeeper가 자주 사용되는 오픈 소스
### 메시지 흐름
#### 1:1 채팅 메시지 처리 흐름
1. 사용자 A가 채팅 서버 1로 메시지 전송
2. 채팅 서버 1은 ID 생성기를 사용해 해당 메시지의 ID 결정
3. 채팅 서버 1은 해당 메시지를 메시지 동기화 큐로 전송
4. 메시지가 키-값 저장소에 보관됨 
5. a) 사용자 B가 접속 중인 경우 메시지는 사용자 B가 접속 중인 채팅 서버로 전송됨 b) 사용자 B가 접속 중이 아니라면 푸시 알림 메시지를 푸시 알림 서버로 보냄
6. 채팅 서버 2는 메시지를 사용자 B에게 전송. 사용자 B와 채팅 서버 2 사이에는 웹소켓 연결이 있는 상태이므로 그것을 이용

* 접속 중이 아닐 때 메시지 큐에서 메시지를 소비했다면 어떻게 채팅 서버로 전송한다는 이야기일까?
#### 여러 단말 사이의 메시지 동기화
* 각 단말은 cur_max_message_id라는 벼수를 유지하는데, 해당 단말에서 관측된 가장 최신 메시지의 ID를 추적하는 용도이다.
* 아래 두 조건을 만족하는 메시지는 새 메시지로 간주한다.
  * 수신자 ID가 현재 로그인한 사용자 ID와 같다.
  * 키-값 저장소에 보관된 메시지로서, 그 ID가 cur_max_message_id보다 크다.

#### 소규모 그룹 채팅에서의 메시지 흐름
* 소규모 그룹 채팅의 경우는 각 사용자마다 수신용 메시지 큐를 갖도록 설계하는 것이 적합하다.
  * 새로운 메시지가 왔는지 확인하려면 자기 큐만 보면 되니까 메시지 동기화 플로우가 단순해진다.
  * 그룹이 크지 않으면 메시지를 수신자별로 복사해서 큐에 넣는 작업의 비용이 문제가 되지 않는다.
* 위챗이 이런 접근법을 쓰고 있으며, 그룹 크기를 500명으로 제한하고 있다.
* 하지만 많은 사용자를 지원해야 하는 경우라면 이런 접근은 바람직하지 않다.

### 접속상태 표시
* 접속 상태 
* 접속 상태 서버는 클라이언트와 웹소켓으로 통신하는 실시간 서비스의 일부라는 점에 유의하라.
#### 사용자 로그인
* 클라이언트와 실시간 서비스 사이에 웹소켓 연결이 맺어지고 나면 접속상태 서버는 A의 상태와 last_active_at 타임스탬프 값을 키-값 저장소에 보관한다.
#### 로그아웃
* API를 통해 로그아웃 호출이 들어오면 키-값 저장소에 보관된 사용자 상태가 offline으로 변경된다.
#### 접속 장애
* heartbeat를 통해서 접속 상태를 체크함
#### 상태 정보의 전송
* 발행-구독 모델을 통해 각각의 친구관계마다 채널을 하나씩 둬서 상태의 변화를 반영한다.
* 사용자가 많아질 경우 성능 문제가 발생하게 되므로 사용자의 접속 상태를 수동으로 갱신하게 하는 것도 좋은 방법이다.
## 마무리
### 채팅 앱을 확장하여 사진, 비디오 등을 지원하는 방법
* 압축, 저장소, 썸네일에 대해 논의해볼 필요가 있음
### 종단 간 암호화
* 왓츠앱은 메시지 발신인과 수신자 이외에는 아무도 메시지 내용을 볼 수 없도록 종단 간 암호화를 지원한다.
### 캐시
* 이미 읽은 메시지를 캐시해 두면 주고받는 데이터 양을 줄일 수 있다.
### 로딩 속도 개선
* 슬랙은 사용자의 데이터, 채널 등을 지역적으로 분산하는 네트워크를 구축하여 로딩 속도를 개선했다.
### 오류 처리
* 채팅 서버 오류: 채팅 서버가 죽을 경우 zookeeper 등으로 클라이언트에게 새로운 서버를 배정하고 다시 접속할 수 있게 해야 한다.
* 메시지 재전송: 재시도나 큐를 통한 재처리