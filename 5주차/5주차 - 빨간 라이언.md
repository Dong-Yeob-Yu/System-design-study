# 9장 

# 웹 크롤러

- 검색 엔진에 널리 쓰는 기술로 웹에 새로 올라오거나 갱신된 콘텐츠를 찾아내는 것이 주된 목적이다.

### 크롤러 이용 종류

- 검색 엔진 인덱싱 : 보편적인 용례, 웹 페이지를 모아 검색 엔진을 위한 로컬 인덱스를 만든다.
- 웹 아카이빙 : 나중에 사용할 목적으로 장기보관하기 위해 웹에서 정보를 모으는 절차를 말한다.
- 웹 마이닝 : 인터넷에서 유용한 지식을 도출해 낼 수 있는 것이다. 예시) 금융 기업의 주주 총회 자료를 받아 핵심 사업 방향을 알아냄
- 웹 모니터링 : 인터넷에서 저작권이나 상표권이 침해되는 사례를 모니터링 가능

![](https://lh4.googleusercontent.com/VViF9KcC_rGtxw0Eu05hClRTwtUNxslXhgPW4wU8vMadeOYZv7D_CFWFAK5DuSRjh-XLMC-HopmEgrvEO-EJO6MBnnxrN_9RUfz94ocFAhB-T-fmDqBMU07QhyGJRcO_Duen8b5rWeDi7XsyMxcqWVQ)

## 시작 URL 집합

- 웹 크롤러가 크롤링을 시작하는 출발점. 예를 들어 어떤 대학 웹사이트를 크롤링 한다면 가장 직관적인 방법은 해당 대학의 도메인 이름이 붙은 URL을 시작 URL로 사용

## 미수집 URL 저장소

- 대부분의 현대적 웹 크롤러는 크롤링 상태를 ‘다운로드할 URL’, ‘다운로드된 URL’ 로 나눠 관리한다. 이 중 다운로드할 URL을 저장 관리하는 컴포넌트를 미수집 URL 저장소라고 부르며 FIFO 구조로 되어있다.

## HTML 다운로더

- 인터넷에서 웹 페이지를 다운로드 하는 컴포넌트, 다운로드할 URL은 미수집 URL 저장소가 제공

## 도메인 이름 변환기

- 웹 페이지를 다운받으려면 URL을 IP 주소로 변환하는 절차가 필요, URL에 대응되는 IP주소를 알아낸다.

## 콘텐츠 파서

- 이상한 웹 페이지는 문제를 일으키므로 파싱(Parsing), 검증(validation) 절차를 거친다.

## 중복 콘텐츠 여부

- 자료 구조를 도입하여 데이터 중복을 줄이고 데이터 처리에 소요되는 시간을 줄인다. HTML 문서를 비교하는 간단한 방법은 문자열로 비교하는것이지만 비교 대상 문서가 10억개에 달하면 느리고 비효율적이라 적용하기 곤란하다. 이때 효과적인 방법은 해시 값을 비교하는 것이다.

## 콘텐츠 저장소

- HTML 문서를 보관하는 시스템이다. 저장소를 구현하는데 쓰일 기술을 고를 때는 저장할 데이터 유형, 크기, 저장소 접근 빈도, 데이터의 유효 기간등을 종합적으로 고려한다.

## URL 추출기

- HTML 페이지를 파싱하여 링크들을 골라내는 역할을 한다. 상대 경로는 전부  절대경로로 변환한다.

## URL 필터

- 특정한 콘텐츠 타입이나 파일 확장자를 갖는 URL, 접속 시 오류가 발생하는 URL, 접근 제외 목록에 포함된 URL 등을 제외하는 역할을 한다.

## 이미 방문한 URL?

- 이미 방문한 URL이나 미수집 URL 저장소에 보관된 URL을 추적할 수 있도록 하는 자료구조를 사용한다. 이는 같은 URL을 여러번 처리하여 서버 부하를 일으키거나 시스템이 무한 루프에 빠지는 일을 방지할 수 있다. 자료구조는 블룸 필터나 해시 테이블이 널리 쓰인다.

## URL 저장소

- 이미 방문한 URL을 보관하는 저장소이다.

# 상세 설계

## DFS vs BFS

- DFS 는 깊이 우선 탐색법이며 좋은 선택이 아닐 가능성이 높다. 그래프 크기가 클 경우 어느 정도로 깊숙이 가게 될지 가늠하기 어려워서다. 따라서 웹 크롤러는 보통 BFS(너비 우선 탐색법) 을 사용한다. BFS는 FIFO 큐를 사용하는 알고리즘이다.
- 표준적 BFS 알고리즘은 URL 간에 우선순위를 두지않는다. 하지만 모든 웹페이지가 같은  수준의 품질, 같은 수준의 중요성을 갖지 않는다. 그러니 여러 가지 척도에 비추어 처리 우선순위를 구별해야한다.

## 미수집 URL 저장소

### 예의

- 이 저장소를 잘 구현하면 ‘예의’ 를 갖춘 크롤러, URL 사이의 우선순위와 신선도를 구별하는 크롤러를 구현할 수 있다. 너무 많은 요청을 보내는것은 ‘무례한’ 일이며 때로는 Dos 공격으로 간주되기도 한다. 가령 아무 안전장치가 없는 웹 크롤러의 경우 사이트를 마비시켜버릴 수 도 있다.
- 예의바른 크롤러 : 한 페이지에 하나의 요청만 보낸다, 같은 웹 사이트의 페이지를 다운받는 테스크는 시간차를 두고 실행하도록 한다.

### 우선순위

- 애플 제품에 대한 사용자 의견이 올라오는 한 페이지와 애플 홈페이지는 같은 중요도를 갖는다고 보기 어렵다. 이런 유용성에 따라 URL의 우선순위를 나눌때는 페이지랭크, 트래픽양, 갱신빈도 등 다양한 척도를 사용할 수 있다.

![](https://lh6.googleusercontent.com/zRGueHRKwl7yooI9CjOBxUQqBFeaLCAPDQL0tL786Pri8t83o3MgIMduM-iNb5tBy9mxiuZOaUSC8zAumlf_ZGWUZ2TrF0ge-WY8vMOpo-rcduVMx3wrQ04Hjq90AGSywVw9PRj6AL5NKX-7YfrbXmA)

- 순위결정장치 : URL을 입력받아 우선순위를 정한다.
- 큐 선택기: 임의 큐에서 처리할 URL을 꺼내는 역할이다. 순위가 높을수록 큐에서 더 자주 꺼낸다.
- 전면 큐 : 우선순위 결정 과정을 처리한다.
- 후면 큐 : 크롤러가 예의 바르게 동작하도록 보증한다.

### 신선도

- 웹 페이지는 수시로 추가, 삭제, 변경된다. 따라서 데이터의 신선함을 유지하기 위해서는 이미 다운로드한 페이지라고 해도 재수집 할 필요가 있다. 하지만 모든 URL을 재수집하는 것은 많은 시간과 자원이 필요하다. 이를 최적화하기 위한 전략은
    1. 웹 페이지의 변경 이력 활용
    2. 우선순위를 활용하여 중요한 페이지는 자주 재수집

### 미수집 URL 저장소를 위한 지속성 저장장치

- 검색 엔진을 위한 크롤러의 경우 수억개의 URL을 처리해야 하기에 메모리에 저장하는것은 안정성이나 규모 확장성 측면에서 바람직하지 못하다. 하지만 전부 디스크에 저장하는 것도 좋은 방법은 아닌데 느려서 쉽게 성능 병목지점이 되기 때문이다. 절충안으로는 대부분의 URL은 디스크에 두지만 I/O 비용을 줄이기 위해 메모리 버퍼에 큐를 두는 것이다. 버퍼에 있는 데이터는 주기적으로 디스크에 기록한다.

## HTML 다운로더

- HTML 다운로더는 HTTP 프로토콜을 통해 웹 페이지를 내려 받는다.

### Robots.txt

- 웹 사이트가 크롤러와 소통하는 표준적 방법이다. 이 파일에는 크롤러가 수집해도 되는 페이지 목록이 들어있다.

### 성능 최적화

- HTML 다운로더에 사용할 수 있는 성능 최적화 기법이다.
    1. 분산 크롤링 : 크롤링 작업을 여러 서버에서 분산하는 방법이다.
    2. 도메인 이름 변환 결과 캐시 : 도메인 이름 변환기는 크롤러 성능의 병목 중 하나인데 DNS 조회 결과로 얻어진 도메인 이름과 IP 주소 사이의 관계를 캐시에 보관해 놓고 크론 잡을 돌려 주기적으로 갱신하도록 해 놓으면 성능을 효과적으로 높일 수 있다.
    3. 지역성 : 크롤링 작업을 수행하는 서버를 지역별로 분산하는 방법이다. 크롤링 대상 서버와 지역적으로 가까우면 페이지 다운로드 시간은 줄어든다. 이를 활용하는 전략은 크롤서버, 캐시, 큐, 저장소 등 대부분 컴포넌트에 적용 가능하다.
    4. 짧은 타임아웃 : 어떤 웹 서버는 응답이 느리거나 아예 응답하지 않는다. 이런 경우에 대기 시간이 길어지면 좋지 않으므로 타임 아웃 시간을 정해두는 것이다.

### 안전성

- 안정해시 : 다운로더 서버들에 부하를 분산할 때 적용 가능한 기술이다. 이 기술을 이용하면 다운로더 서버를 쉽게 추가하고 삭제 할 수 있다.
- 크롤링 상태 및 수집 데이터 저장 : 장애가 발생한 경우에도 쉽게 복구할 수 있도록 크롤링 상태와 수집된 데이터를 기록해 두는 것이 바람직하다.
- 예외처리 : 대규모 시스템에서 에러는 불가피할 뿐 아니라 흔하게 벌어지는 일이다. 예외가 발생해도 전체 시스템은 중단되지 않고 작업을 이어 나가야 한다.
- 데이터 검증 : 시스템 오류를 방지하기 위한 중요 수단 가운데 하나다.

### 확장성

- 진화하지 않는 시스템은 없는 법이라서, 이런 시스템을 설계할 때는 새로운 형태의 콘텐츠를 쉽게 지원할 수 있도록 신경써야한다. 새로운 모듈을 끼워 넣음으로써 새로운 형태의 콘텐츠를 지원할 수 있도록 설계 할 수 있다.

### 문제 있는 콘텐츠 감지 및 회피

1. 중복 컨텐츠 : 웹 콘텐츠의 30% 가량은 중복이다. 해시나 체크섬을 사용하면 중복 컨텐츠를 보다 쉽게 탐지할 수 있다.
2. 거미 덫 : 거미 덫은 크롤러를 무한 루프에 빠뜨리도록 설계한 웹 페이지다. 이런 덫은 URL의 최대 길이를 제한하면 회피할 수 있다. 하지만 모든 종류의 덫을 피할 수 있는 만능 해결책은 없다. 한 가지 방법은 사람이 수작업으로 덫을 확인하고 찾아낸 후에 덫이 있는 사이트를 탐색 대상에서 제외하거나 URL 필터 목록에 거렁두는 것이다.
3. 데이터 노이즈 : 광고나 스크립트 코드, 스팸 URL 같은 것은 아무 가치가 없다. 이런 콘텐츠는 가능하다면 제외 해야 한다.

------------- 

# 10장 
# 알림 시스템 설계

## 알림 유형별 지원 방안

- IOS 푸시 알림 : IOS 에서 푸시 알림을 보내기 위해서는 세 가지 컴포넌트가 필요하다.
  1. 알림 제공자 : 알림 요청을 만들어 애플 푸시 알림 서비스 (APNS)로 보내는 주체, 알림 요청을 만들려면 단말토큰(고유 식별자), 페이로드(알림 내용등을 담은 딕셔너리)가 필요하다
  2. APNS : 애플이 제공하는 원격 서비스, 푸시 알림을 IOS로 보내는 역할을 담당한다.
  3. IOS 단말 : 푸시 알림을 수신하는 사용자 단말이다.
- 안드로이드 푸시 알림 : 안드로이드 푸시 알림도 비슷한 절차로 전송된다. APNS 대신 FCM(Firebase Cloud Messaging)을 사용하는 점이 다르다.
- SMS 메시지 : SMS 메시지를 보낼 때는 보통 제 3사업자의 서비스를 많이 이용한다. 이런 서비스는 대부분 상용 서비스 이다.
- 이메일 : 자회사의 이메일 서버를 사용하거나 상용 이메일 서비스등을 이용한다.

## 연락처 정보 수집 절차

- 알림을 보낼려면 모바일 단말 토큰, 전화번호, 이메일 주소 등의 정보가 필요하다. 사용자가 앱을 설치하거나 처음으로 계정을 등록할때 API 서버는 사용자의 정보를 수집하여 DB에 저장한다.

## 알림 전송 및 수신 절차

![](https://velog.velcdn.com/images/haron/post/c3d6a47f-99e3-43ae-b688-c4ee728524d9/image.png)

1. 1~N 까지의 서비스 : 이 서비스는 microservice, 크론잡, 분산 시스템 컴포넌트 일수도 있다. 예로 과금서비스, 배송알림을 보내는 쇼핑몰 웹사이트 등이 있다.
2. 알림 시스템 : 알림 시스템은 알림 전송/수신 처리의 핵심이다. 우선은 1개 서버만 사용하는 시스템이고 이 시스템은 서비스 1~N에 알림 전송을 위한 API를 제공해야 하고, 제3자 서비스에 전달할 알림 페이로드를 만들어 낼 수 있어야 한다.
3. 제3자 서비스 : 이 서비스들은 사용자에게 알림을 실제로 전달하는 역할을 한다. 해당 서비스를 진행할 때 유의할 점은 확장성 이다. 쉽게 새로운 서비스를 통합하거나 기존 서비스를 제거할 수 있어야 한다.
4. IOS, 안드로이드, SMS, 이메일 단말 : 사용자는 자기 단말에서 알림을 수신 한다.

- 해당 설계에는 몇 가지 문제가 있다.
1. SPOF : 알림 서비스에 서버가 하나밖에 없으므로 장애가 생기면 전체 서비스의 장애로 이어진다.
2. 규모 확장성 : 한 대 서비스로 푸시 알림에 관계된 모든 것을 처리하므로, DB나 캐시 등 중요 컴포넌트의 규모를 개별적으로 늘릴 방법이 없다.
3. 성능 병목 : 알림을 처리하고 보내는 것은 자원을 많이 필요로 하는 작업이다. 예를 들어 HTML 페이지를 만들고 제 3자 서비스의 응답을 기다리는 일은 시간이 많이 걸릴 가능성이 있는 작업이다. 따라서 하나의 서버로 처리하면 사용자 트래픽이 많이 몰리는 시간에는 시스템 과부하 상태에 빠질 수 있다.

- 개선안
1. DB와 캐시를 알림 시스템의 주 서버에서 분리한다.
2. 알림 서버를 증설하고 자동으로 수평적 규모 확장이 이루어질 수 있도록 한다.
3. 메시지 큐를 이용해 시스템 컴포넌트 사이의 강한결합을 끊는다.

![](https://user-images.githubusercontent.com/108508730/228560510-9efda38c-ed08-4462-b60c-9907980aea76.png)

## 상세 설계

### 안전성

- 분산 환경에서 운영될 알림 시스템을 설계할 때는 안정성을 확보하기 위한 사항 몇 가지를 반드시 고려해야한다.
  - 데이터 손실 방지 : 알림 전송 시스템의 가장 중요한 요구사항 중 하나는 어떤 상황에서도 알림이 소실되면 안된다. 이 요구사항을 만족하려면 알림 시스템은 알림 데이터를 DB에 저장하고 재시도 매커니즘을 구현해야한다.
  - 알림 중복 전송 방지 : 같은 알림이 여러번 발송되는것을 완전히 막을 방법은 없다. 하지만 중복을 탐지하는 매커니즘을 도입하여 빈도를 줄일 수 있다.

### 추가로 필요한 컴포넌트 및 고려사항

- 알림 템플릿 : 대형 알림 시스템은 하루에도 수백만 건 이상의 알림을 처리한다. 그런데 알림 메시지 대부분은 형식이 비슷하다. 알림 템플릿은 이런 유사성을 고려하여, 알림 메시지의 모든 부분을 처음부터 다시 만들 필요 없도록 해준다.
- 알림 설정 : 사용자는 이미 많은 알림을 받고 있어서 쉽게 피곤함을 느낀다. 따라서 사용자가 알림 설정을 상세히 조정할 수 있도록 해야한다. 예시 항목으론 알림이 전송될 채널 (app, email, sms 등), 알림 여부 등이 있다.
- 전송률 제한 : 사용자에게 너무 많은 알림을 보내지 않는 방법으론 사용자가 받을 수 있는 알림의 빈도를 제한하는 것이다. 예시로는 시간 기반 제한, 알림 그룹화(좋아요 그룹화), 우선순위 기반(긴급, 광고 등) 이 있다.
- 재시도 방법 : 제3자 서비스가 알림 전송에 실패하면, 해당 알림을 재시도 전용 큐에 넣는다. 같은 문제가 계속해서 발생하면 개발자에게 통지한다.
- 푸시 알림과 보안 : IOS와 안드로이드 앱의 경우 알림 전송 API는 appKey와 appSecret을 사용하여 보안을 유지한다. 따라서 인증됐거나 승인된 클라이언트만 해당 API를 사용하여 알림을 보낼 수 있다.
- 큐 모니터링 : 알림 시스템을 모니터링 할때 중요한 메트릭 하나는 큐에 쌓인 알림의 갯수이다. 이 갯수가 크면 작업 서버들이 이벤트를 빠르게 처리하고 있지 못하다는 뜻이다. 그럴 경우 작업 서버를 증설할 근거로 삼을 수 있다.
- 이벤트 추적 : 알림 확인율, 클릭율, 실제 앱 사용으로 이어지는 비율 같은 메트릭은 사용자를 이해하는데 중요하다. 데이터 분석 서비스는 보통 이벤트 추적 기능도 제공한다. 따라서 알림 시스템을 만들면 데이터 분석 서비스와도 통합해야만 한다.