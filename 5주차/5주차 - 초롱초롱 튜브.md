# 9장. 웹 크롤러 설계

웹 크롤러(web crawler)는 검색 엔진에서 널리 쓰이는 기술로, 웹에 새로 올라오거나 갱신된 콘텐츠를 찾아낸다.

웹 크롤러는 몇 개의 웹 페이지에서 시작하여 그 링크를 따라 나가면서 새로운 콘텐츠를 수집하는데, 다음과 같이 다양하게 이용된다.

- 검색 엔진 인덱싱(search engine indexing) : 크롤러의 가장 보편적인 용례로, 크롤러는 웹 페이지를 모아 검색 엔진을 위한 **로컬 인덱스**(local index)를 만든다.

- 웹 아카이빙(web archiving) : 나중에 사용할 목적으로 **장기보관**하기 위해 웹에서 정보를 모으는 절차를 말한다. 많은 국립 도서관들이 크롤러를 돌려 웹 사이트를 아카이빙하고 있다.
  
- 웹 마이닝(web mining) : 인터넷에서 유용한 지식을 도출해낸다. (**데이터 마이닝**)
  
- 웹 모니터링(web monitoring) : 인터넷에서 저작권이나 상표권이 침해되는 사례를 **모니터링**한다.

웹 크롤러의 복잡도는 처리하는 **데이터의 규모**에 따라 달라지므로 설계할 웹 크롤러가 처리하는 데이터의 규모와 기능들을 알아야 한다.

## 웹 크롤러 알고리즘

웹 크롤러의 기본 알고리즘은 다음과 같다.

1. URL 집합이 입력으로 주어지면, 해당 URL이 가리키는 모든 웹 페이지를 다운로드한다.
   
2. 다운받은 웹 페이지에서 URL들을 추출한다.
   
3. 추출된 URL들을 다운로드할 URL 목록에 추가하고 위 과정을 반복한다.

그러나 실제 동작 시 이렇게 단순하게 동작하지는 않는다. 실제 면접에서는 다음과 같이 요구사항을 통해 설계 범위를 좁혀야 한다.

- 매달 10억 개의 웹 페이지를 다운로드한다.
  
- QPS = 10억 페이지/30일/24시간/3600초 = 대략 400페이지/초
  
- 최대 QPS = 2 * QPS = 800페이지/초
  
- 평균 웹 페이지 크기 = 500k
  
- 10억 페이지 * 500k = 500TB/월

주어진 요구사항 외에 다음 속성들도 고려하는 것이 좋다.

- 규모 확장성 : 거대한 웹에서 병행성(parallelism)을 활용하면 효과적으로 크롤링을 할 수 있다.
  
- 예절(politeness) : 수집 대상 웹 사이트에 짧은 시간 동안 너무 많은 요청을 보내서는 안된다.
  
- 안정성(robustness) : 비정상적 입력이나 환경에 잘 대응해야 한다.
  
- 확장성(extensibility) : 새로운 형태의 콘텐츠를 지원하기 쉬워야 한다.

## 웹 크롤러 컴포넌트

웹 크롤러의 개략적 설계는 다음과 같다.

![image](https://github.com/user-attachments/assets/0bf98809-4393-4120-b759-6edc955dd6e2)

### 시작 URL 집합

웹 크롤러는 **시작 URL로부터 크롤링을 시작**하며, 이 시작 URL이 여러 개가 존재하면 집합을 이룬다.

전체 웹을 크롤링해야 하는 경우에는 크롤러가 **가능한 많은** 링크를 탐색할 수 있도록 시작 URL을 골라야 한다. 일반적으로는 나라별, 주제별 등의 기준에 의해 전체 URL 공간을 작은 부분집합으로 나누는 전략을 쓴다.

### 미수집 URL 저장소

웹 크롤러는 크롤링 상태를 다운로드할 URL과 다운로드된 URL로 나누어 관리한다. 이 중 **다운로드할 URL을 저장/관리하는 컴포넌트**를 미수집 URL 저장소(URL frontier)라고 한다.

### HTML 다운로더와 도메인 이름 변환기

HTML 다운로더는 **인터넷에서 웹 페이지를 다운로드하는 컴포넌트**다. 다운로드할 페이지의 URL은 미수집 URL 저장소가 제공한다.

HTML 다운로더는 **도메인 이름 변환기**를 사용하여 URL에 대응되는 IP 주소를 알아낸다.

### 콘텐츠 파서

웹 페이지를 다운로드하기 위해 **파싱(parsing)과 검증(validation) 절차**를 거쳐야 하는데, 이를 위해 콘텐츠 파서가 필요하다. 크롤링 서버 안에 콘텐츠 파서를 구현하면 크롤링이 느려지므로 독립된 컴포넌트로 존재한다.

### 콘텐츠 저장소

웹 페이지의 **해시 값**을 비교하여 **이미 시스템에 저장된 콘텐츠인지** 여부를 알아내야 한다.

이때 **HTML 문서를 보관**하는 컴포넌트를 콘텐츠 저장소라고 한다. 저장소를 구현할 때에는 저장할 데이터의 유형, 크기, 저장소 접근 빈도, 데이터 유효 기간 등을 종합적으로 고려해야 한다.

### URL 추출기

URL 추출기는 **HTML 페이지를 파싱하여 링크들을 골라내**는 컴포넌트다. 상대 경로를 절대 경로로 추출하는 작업 등이 있다.

### URL 필터

URL 필터는 특정 콘텐츠 타입이나 파일 확장자를 갖는 URL, 접속 시 오류가 발생하는 URL, 접근 제외 목록에 포함된 URl 등을 **크롤링 대상에서 배제**하는 컴포넌트다.

### 중복 URL 확인

이미 방문한 URL이나 미수집 URL 저장소에 보관된 URL을 추적할 수 있는 자료구조를 사용한다. 이로써 **같은 URL을 여러 번 처리하는 것을 방지**하여 서버 부하를 줄이고 시스템이 무한 루프에 빠지는 일을 방지할 수 있다.

해당 자료 구조로는 블룸 필터(bloom filter)나 해시 테이블이 주로 쓰인다.

### URL 저장소

URL 저장소는 **이미 방문한 URl을 보관**하는 컴포넌트다.

이 시스템 컴포넌트들의 상호 연동 흐름을 살펴보자.

1. 시작 URL들을 미수집 URL 저장소에 저장한다.
   
2. HTMl 다운로더는 미수집 URL 저장소에서 URL 목록을 가져온다.
   
3. HTML 다운로더는 도메인 이름 변환기를 사용하여 URL의 IP 주소를 알아내고, 해당 IP 주소로 접속하여 웹 페이지를 다운받는다.
   
4. 콘텐츠 파서는 다운된 HTML 페이지를 파싱하여 올바른 형식을 갖춘 페이지인지 검증한다.
   
5. 콘텐츠 파싱과 검증이 끝나면 중복 콘텐츠인지 판별한다. 이를 위해 해당 페이지가 이미 저장소에 있는지 확인한다.
    1. 이미 저장소에 있는 경우, 처리하지 않고 버린다.
    2. 저장소에 없는 경우, 저장소에 저장한 뒤 URL 추출기로 전달한다.
       
6. URL 추출기는 해당 HTML 페이지에서 링크를 골라내어 URL 필터로 전달한다.
   
7. URL 필터에서 필터링을 거친 URL에 대해 중복 URL인지 판별한다. 이를 위해 URL 저장소에 보관되어 있는지 확인한다.
    1. 이미 처리한 URL인 경우, 처리하지 않고 버린다.
    2. 저장소에 없는 경우, URL 저장소에 저장하고 미수집 URL 저장소에도 전달한다.

## 가장 중요한 컴포넌트와 구현 기술

### DFS vs BFS

크롤링 프로세스는 edge(URL)를 따라 directed graph(웹)를 탐색하는 과정이다. 이때 DFS는 적합한 기법이 아닌데, 그래프 크기가 클 경우 얼마나 깊게 갈지 가늠할 수 없기 때문이다.

따라서 웹 크롤러는 보통 **BFS**를 사용한다. BFS에서 사용하는 FIFO 큐의 한 쪽으로는 탐색할 URL을 넣고, 다른 한 쪽으로는 이를 꺼낸다. 하지만 여기엔 두 가지 문제점이 있다.

1. 한 페이지에서 나오는 링크의 상당수는 같은 서버로 되돌아간다. 
    
    ![image](https://github.com/user-attachments/assets/2aea0b11-d6ee-4e41-af99-05e02c481d42)
    
    이때 크롤러는 같은 호스트에 속한 많은 링크를 다운받느라 바빠지는데, 링크를 병렬로 처리한다면 서버는 수많은 요청으로 과부하에 걸리게 될 것이다. 이런 크롤러는 보통 예의 없는(impolite) 크롤러로 간주된다.
    
2. 웹 페이지는 페이지 순위(page rank), 트래픽의 양 등에 따라 처리 우선순위가 존재하지만, **표준적 BFS 알고리즘 상으로는 URL 간에 우선순위를 두지 않아** 우선순위를 반영할 수가 없다.

### 미수집 URL 저장소

다운로드할 URL을 보관하는 미수집 URL 저장소를 통해 예의(politeness)를 갖춘 크롤러와 URL 사이의 우선순위 및 신선도(freshness)를 반영하는 크롤러를 구현할 수 있다.

#### 예의

웹 크롤러는 수집 대상 서버로 짧은 시간 안에 너무 많은 요청을 보내는 것을 삼가야 한다. 이는 무례한(impolite) 일이며, 때로는 DoS(Denial-of-Service) 공격으로 간주되기도 한다.

예의 바른 크롤러를 만들기 위해서는 **동일 웹 사이트에 대해서는 한 번에 한 페이지만 요청**하고, 같은 웹 사이트에 대해 여러 번 요청을 보내야 할 경우에는 **시간차**를 두고 실행해야 한다.

이를 만족시키기 위해서는 각 다운로드 스레드가 별도의 FIFO 큐를 가지게 함으로써, 해당 큐에서 꺼낸 URL만 다운로드해야 한다.

![image](https://github.com/user-attachments/assets/192dc280-3acb-42f8-bdca-8109d06212f0)

- 큐 라우터(queue router) : 같은 호스트에 속한 URL은 언제나 같은 큐로 가도록 보장한다.
  
- 매핑 테이블(mapping table) : 호스트 이름과 큐 사이의 관계를 저장한다.
  
- 큐 선택기(queue selector) : 큐들을 순회하며 큐에서 URL을 꺼내 이를 다운로드하도록 지정된 작업 스레드에 전달한다.
  
- 작업 스레드(worker thread) : 전달된 URL을 순차적으로 다운로드하며, 작업들 사이에는 일정한 지연시간을 둘 수 있다.

#### 우선순위

URL의 우선순위를 나눌 때에는 PageRank, 트래픽 양, 갱신 빈도 등 다양한 척도를 사용할 수 있는데, 이때 **순위결정장치**(prioritizer)를 통해 URL 우선순위를 정할 수도 있다.

![image](https://github.com/user-attachments/assets/5527af84-f7a1-4a7e-8027-f9f23b49c44f)

- 순위결정장치(prioritizer) : URL을 입력으로 받아 우선순위를 계산한다.
  
- 큐 : 우선순위별로 큐가 할당되며, 우선순위가 높을수록 선택될 확률도 높아진다.
  
- 큐 선택기 : 임의 큐에서 처리할 URL을 꺼내며, 우선순위가 높은 큐에서 더 자주 꺼낸다.

<hr/>

위 사항들을 모두 반영한 전체 설계는 다음과 같다. 전면 큐에서는 우선순위를 결정하고, 후면 큐에서는 크롤러가 예의 바르게 동작하도록 보증한다.

![image](https://github.com/user-attachments/assets/b593c5b8-6548-44e6-bdab-b414b6271c59)

#### 신선도

웹 페이지는 수시로 추가/삭제/변경되므로 데이터의 신선함(freshness)를 유지하기 위해서는 이미 다운로드된 페이지여도 주기적으로 재수집(recrawl)할 필요가 있다.

그러나 모든 URL을 재수집하는 것은 많은 시간과 자원이 소모되는데, 이를 최적화하기 위해 **웹 페이지의 변경 이력을 활용**하거나, 우**선순위를 기반으로 중요한 페이지를 자주 재수집**할 수 있다.

**미수집 URL 저장소를 위한 지속성 저장장치**

검색 엔진을 위한 크롤러의 경우, 처리해야 하는 URL은 수억 개에 달한다. 이 모두를 메모리에 보관하는 것은 안정성이나 규모 확장성 측면에서 좋지 않고, 그렇다고 모두를 디스크에 보관하는 것도 성능 병목지점이 되기 쉬워 바람직하지 않다.

따라서 **대부분의 URL은 디스크에** 저장하되, I/O 비용을 줄이기 위해 **메모리 버퍼에 큐를** 두는 방식이 좋다.

### HTML 다운로더

#### Robots.txt (Robot Exclusion Protocol)

Robots.txt는 웹사이트가 크롤러와 소통하는 표준 방법으로, 이 파일에는 **크롤러가 수집해도 되는 페이지 목록**이 들어있다. 따라서 크롤러는 웹 사이트를 다운받기 전에 **해당 파일의 규칙을 먼저 확인**해야 한다.

Robots.txt 파일을 불필요하게 다운로드하는 것을 피하기 위해, 이 파일은 **주기적으로 다시 다운되어 캐시에 보관**된다.

#### 성능 최적화

1. **분산 크롤링**

크롤링 작업을 **여러 서버**에 분산하여 성능을 높일 수 있다. 각 서버는 **여러 스레드**를 통해 다운로드 작업을 처리하는데, **URL 공간을 작은 단위로 분할**하여 각 서버가 그 중 일부를 다운로드하는 방식이다.

![image](https://github.com/user-attachments/assets/60c33865-1421-45f3-a78c-cf208b0a4464)

2. **도메인 이름 변환 결과 캐시**

도메인 이름 변환기(DNS Resolver)는 **DNS 요청의 동기적 특성** 때문에 크롤러 성능의 병목 중 하나이다. 크롤러 스레드 중 어느 하나라도 DNS 응답을 기다리고 있으면, 다른 스레드의 DNS 요청은 모두 블록되기 때문이다.

따라서 **DNS 조회 결과로 얻은 도메인 이름과 IP 주소 사이의 관계를 캐시에 보관**해두고, 크론 잡(cron job) 등을 통해 **주기적으로 갱신**시킴으로써 성능을 높일 수 있다.

3. **지역성**

크롤링 서버를 **지역별로 분산**시켜 크롤링 대상 서버들과의 거리를 좁힘으로써 페이지 다운로드 시간을 줄이는 방법이다. (지역성을 활용하는 전략은 크롤링 서버, 캐시, 큐, 저장소 등 대부분의 컴포넌트에 적용 가능하다.)

4. **짧은 타임아웃**

웹 서버가 응답이 느리거나 아예 응답하지 않을 수도 있으므로, **최대 대기 시간을 미리 정해두는** 방법이다. 이 시간 동안 서버가 응답하지 않으면 크롤러는 해당 페이지 다운로드를 중단하고 다음 페이지로 넘어간다.

#### 안정성

1. **안정 해시(consistent hashing)** : 다운로더 서버들에 **부하를 분산**할 때 적용 가능한 기술로, 이를 통해 다운로더 서버를 쉽게 추가 및 삭제할 수 있다.

2. **크롤링 상태 및 수집 데이터 저장** : **크롤링 상태와 수집된 데이터를 영구 저장장치에 저장**해놓음으로써, **장애** 발생 시 이를 로딩하여 **쉽게 복구**할 수 있다.

3. **예외 처리(exception handling) 및 데이터 검증(data validation)**

#### 확장성

새로운 형태의 콘텐츠를 쉽게 지원하기 위해 다음과 같이 PNG 다운로더, 웹 모니터 등의 모듈을 추가할 수 있다.

![image](https://github.com/user-attachments/assets/f866667d-ffee-4d4b-a813-3bbda74bc3af)

#### 문제가 있는 콘텐츠 감지 및 회피 전략

1. **중복 콘텐츠** : 웹 콘텐츠의 30% 가량은 중복이므로, 해시값이나 check-sum 등을 통해 중복 콘텐츠를 검증해야 한다.
   
2. **거미 덫** : 크롤러를 무한 루프에 빠뜨리는 웹 페이지로, 무한히 깊은 디렉토리 구조를 포함하는 링크가 그 예시이다. URL의 최대 길이를 제한하는 등의 방식으로 회피할 수 있다.
   
3. **데이터 노이즈** : 광고, 스팸 URL 등과 같이 가치가 없는 콘텐츠는 크롤링에서 제외해야 한다.

## 추가 논의사항

- 서버 사이드 렌더링 : JS, AJAX 등으로 개발된 웹 페이지를 있는 그대로 파싱해보면 동적으로 생성되는 링크를 발견할 수 없다. 이 문제는 페이지를 파싱하기 전에 서버 사이드 렌더링(동적 렌더링)을 적용하여 해결할 수 있다.
  
- 원치 않는 페이지 필터링 : 크롤링에 소모되는 자원은 유한하므로 스팸 방지 컴포넌트를 통해 필터링하는 것이 좋다.
  
- 데이터베이스 다중화 및 샤딩 / 서버의 수평적 규모 확장성
  
- 데이터 분석 솔루션(analytics)
  
- 가용성, 일관성, 안정성

# 10장. 알림 시스템 설계

알림 시스템(notification system)은 고객에게 중요할 만한 정보를 비동기적으로 제공한다. 이는 단순히 모바일 푸시 알림에 한정되지 않고, SMS 메시지, 이메일도 포함한다.

이 책에서는 iOS 및 안드로이드 푸시 알림, SMS 메시지, 이메일을 지원하는 알림 시스템을 설계해볼 것이다.

## 개략적 설계

### 알림 유형별 지원 방안

**iOS 푸시 알림**

iOS에서 푸시 알림을 보내기 위해 다음 세 가지 컴포넌트가 필요하다.

![image](https://github.com/user-attachments/assets/1b866616-d642-471d-9d3b-2aeb5079bd81)

**알림 제공자(provider)**

- **알림 요청(notification request)을 만들어 APNS로 보낸**다.
  
- 다음 데이터를 이용해 알림 요청을 만든다.
  
    - 단말 토큰(device token) : 알림 요청에 필요한 고유 식별자
      
    - 페이로드(payload) : 알림 내용을 담은 JSON 딕셔너리

**APNS(Apple Push Notification Service)**

- 애플이 제공하는 원격 서비스로, **푸시 알림을 iOS 장치로 보내**준다.

**iOS 단말**

- 푸시 알림을 수신하는 사용자 단말이다.

**안드로이드 푸시 알림**

안드로이드 푸시 알림도 iOS와 비슷한 절차로 전송되는데, APNS 대신 **FCM**(Firebase Cloud Messaging)을 사용한다.

![image](https://github.com/user-attachments/assets/68a12714-c21b-4d7c-bebc-265f12ada21c)

**SMS 메시지**

보통 트윌리오(Twilio), 넥스모(Nexmo)와 같은 **제3사업자의 서비스**(third party service)를 주로 이용하는데, 대부분 상용 서비스라서 과금이 발생한다.

![image](https://github.com/user-attachments/assets/8636ef72-84b0-43c4-8383-4099b63dfca3)

**이메일**

보통 **상용 이메일 서비스**를 이용하며, 유명한 서비스로 센드그리드(Sendgrid), 메일침프(Mailchimp)가 있다.

![image](https://github.com/user-attachments/assets/8932c86d-3f5e-49bf-b387-900da457ea84)

### 연락처 정보 수집 절차

알림을 보내기 위해서는 모바일 단말 토큰, 전화번호, 이메일 주소 등의 정보가 필요하다. 사용자가 앱 설치 또는 계정 등록을 하게 되면 API 서버는 해당 사용자의 정보를 수집하여 DB에 저장한다.

이때 한 사용자가 여러 단말을 보유할 수 있고, 알림은 모든 단말에 전송되어야 한다는 점을 고려하여 DB를 설계해야 한다.

### 알림 전송 및 수신 절차

다음은 알림 전송 및 수신 절차의 개략적인 설계안이다.

![image](https://github.com/user-attachments/assets/984ccd0a-0a19-473f-8572-4344745ee1ef)

- 1부터 N까지의 서비스 : 사용자에게 **알림을 전송하고자** 하는 서비스들이다.
  
- 알림 시스템(하나의 서버) : 알림 전송/수신 처리의 핵심으로, 1~N **서비스에 알림 전송을 위한 API를 제공**, 제3자 서비스(서드 파티 서비스)에 전달할 **알림 페이로드를 생성**한다.
  
- 서드 파티 서비스 : **사용자에게 알림을 실제로 전달**한다. **확장성**이 보장되어 서드 파티 서비스를 쉽게 통합/제거할 수 있어야 한다. 또한 **시장에 따라** 특정 서비스를 사용하지 못할 수도 있음을 고려해야 한다.
  
- iOS, 안드로이드, SMS, 이메일 단말 : 사용자는 **자신의 단말에서 알림을 수신**한다.

이 설계에 따르면 알림 서비스에 서버가 하나밖에 없는데, 이에 따라 몇 가지 문제점이 발생한다.

> 알림 서비스가 **SPOF**가 될 수 있을 뿐더러, 데이터베이스나 캐시 등의 **규모를 개별적으로 확장하기 어렵**다.

> 또한 트래픽이 몰려 리소스를 많이 쓰는 작업에 대해서는 **성능 상의 병목**이 생길 수 있다.

이러한 문제들을 개선한 것이 다음 설계안이다.

> 데이터베이스와 캐시를 알림 시스템의 주 서버에서 **분리**한다.

> 알림 서버를 **증설**하고, 자동으로 수평적 규모 확장이 가능하게 한다.

> **메시지 큐**를 이용해 시스템 컴포넌트 사이의 강한 결합을 끊는다.

![image](https://github.com/user-attachments/assets/3347e006-168a-415a-8781-9ce963e097f2)

초안과 달라진 부분을 살펴보자.

- 알림 서버
  
    - 알림 전송 API 제공 : 스팸 방지를 위해 인증된 클라이언트만 이용 가능
      
    - 알림 검증(validation) : 이메일 주소, 전화번호 등에 대한 기본적 검증
      
    - 데이터베이스 또는 캐시 질의 : 알림에 포함시킬 데이터를 가져옴
      
    - 알림 전송 : 알림 데이터를 메시지 큐에 삽입
      
- 캐시(cache) : 사용자 정보, 단말 정보, 알림 템플릿 등을 캐시한다.
  
- 데이터베이스(DB) : 사용자, 알림, 설정 등을 저장한다.
  
- 메시지 큐(message queue) : **시스템 컴포넌트 간의 의존성을 제거하기 위해** 사용된다. **다량의 알림이 전송되는 경우를 대비한 버퍼** 역할 또한 수행한다.
  
- 작업 서버(workers) : 메시지 큐에서 전송할 알림을 꺼내서 서드 파티 서비스로 전달한다.

이 컴포넌트들의 알림 전송 플로우는 다음과 같다.

1. API를 호출하여 알림 서버로 알림을 보낸다.
   
2. 알림 서버는 사용자 정보, 단말 토큰, 알림 설정 같은 메타데이터를 캐시나 데이터베이스에서 가져온다.
   
3. 알림 서버는 전송할 알림에 맞는 이벤트를 만들어서 해당 이벤트를 위한 메시지 큐에 넣는다.
   
4. 작업 서버는 메시지 큐에서 알림 이벤트를 꺼내 서드 파티 서비스로 보낸다.
   
5. 서드 파티 서비스는 사용자 단말로 알림을 전송한다.

## 구체적 설계

### 안정성

분산 환경에서 운영될 알림 시스템을 설계할 때에는 안정성을 확보하는 것이 중요하다.

**데이터 손실 방지**

알림 전송 시스템에서는 **어떤 상황에서도 알림이 소실되면 안 된다.**

이를 만족하려면 알림 시스템은 **알림 데이터를 데이터베이스에 보관하면서 재시도 메커니즘을 구현**해야 하는데, 알림 로그(notification log) 데이터베이스를 유지하는 방법이 있다.

**알림 중복 전송 방지**

분산 시스템에서는 알림이 중복되어 전송될 수도 있다. 이를 100% 방지할 수는 없지만 빈도를 줄이기 위해서는, **중복 탐지 메커니즘을 도입**하고 오류를 신중하게 처리해야 한다. 이벤트 ID 등을 통해 중복 여부를 판단할 수 있다.

### 추가로 필요한 컴포넌트 및 고려사항

**알림 템플릿**

알림 템플릿이란 파라미터나 스타일, 링크 등을 조정하여 **알림 메시지 간의 유사한 형식에 맞춰** 알림을 만들어내는 틀이다. 이를 통해 형식의 일관성을 유지할 수 있고, 오류 가능성과 알림 작성에 드는 시간도 줄일 수 있다.

**알림 설정**

사용자가 알림 수신에 대해 조정해놓은 설정(**알림 설정 테이블**)에 따라 알림을 보내야 한다. 

**전송률 제한**

알림을 너무 많이 보낸다면 사용자가 기능을 아예 끌 수도 있기 때문에, 한 사용자가 받을 수 있는 **알림 빈도를 제한**하기도 한다.

**재시도 방법**

서드 파티 서비스가 알림 전송에 실패하면 해당 알림을 **재시도 전용 큐**에 넣는다. 같은 문제가 계속해서 발생하면 개발자에게 알린다.

**푸시 알림과 보안**

iOS와 안드로이드 앱의 경우 **인증된(authenticated), 혹은 승인된(verificated) 클라이언트만**이 알림 전송 API를 사용할 수 있다.

**큐 모니터링**

알림 시스템 모니터링 시 **큐에 쌓인 알림의 개수**를 중요하게 보아야 한다. 개수가 너무 많다는 것은 작업 서버들이 이벤트를 **빠르게 처리하지 못한다**는 것이므로, 작업 서버를 증설해야 한다.

**이벤트 추적**

이벤트 추적 기능을 제공하는 데이터 분석 서비스를 알림 시스템에 포함시킴으로써 여러 메트릭을 통해 사용자를 잘 분석할 수 있다.

<hr/>

위 사항들을 모두 반영한 설계안은 다음과 같다.

![image](https://github.com/user-attachments/assets/76768fc1-813a-466d-a584-057e12bbf915)
