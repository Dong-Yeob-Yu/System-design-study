# 9장. 웹 크롤러 설계

웹 크롤러(web crawler)는 검색 엔진에서 널리 쓰이는 기술로, 웹에 새로 올라오거나 갱신된 콘텐츠를 찾아낸다.

웹 크롤러는 몇 개의 웹 페이지에서 시작하여 그 링크를 따라 나가면서 새로운 콘텐츠를 수집하는데, 다음과 같이 다양하게 이용된다.

- 검색 엔진 인덱싱(search engine indexing) : 크롤러의 가장 보편적인 용례로, 크롤러는 웹 페이지를 모아 검색 엔진을 위한 **로컬 인덱스**(local index)를 만든다.

- 웹 아카이빙(web archiving) : 나중에 사용할 목적으로 **장기보관**하기 위해 웹에서 정보를 모으는 절차를 말한다. 많은 국립 도서관들이 크롤러를 돌려 웹 사이트를 아카이빙하고 있다.
  
- 웹 마이닝(web mining) : 인터넷에서 유용한 지식을 도출해낸다. (**데이터 마이닝**)
  
- 웹 모니터링(web monitoring) : 인터넷에서 저작권이나 상표권이 침해되는 사례를 **모니터링**한다.

웹 크롤러의 복잡도는 처리하는 **데이터의 규모**에 따라 달라지므로 설계할 웹 크롤러가 처리하는 데이터의 규모와 기능들을 알아야 한다.

## 웹 크롤러 알고리즘

웹 크롤러의 기본 알고리즘은 다음과 같다.

1. URL 집합이 입력으로 주어지면, 해당 URL이 가리키는 모든 웹 페이지를 다운로드한다.
   
2. 다운받은 웹 페이지에서 URL들을 추출한다.
   
3. 추출된 URL들을 다운로드할 URL 목록에 추가하고 위 과정을 반복한다.

그러나 실제 동작 시 이렇게 단순하게 동작하지는 않는다. 실제 면접에서는 다음과 같이 요구사항을 통해 설계 범위를 좁혀야 한다.

- 매달 10억 개의 웹 페이지를 다운로드한다.
  
- QPS = 10억 페이지/30일/24시간/3600초 = 대략 400페이지/초
  
- 최대 QPS = 2 * QPS = 800페이지/초
  
- 평균 웹 페이지 크기 = 500k
  
- 10억 페이지 * 500k = 500TB/월

주어진 요구사항 외에 다음 속성들도 고려하는 것이 좋다.

- 규모 확장성 : 거대한 웹에서 병행성(parallelism)을 활용하면 효과적으로 크롤링을 할 수 있다.
  
- 예절(politeness) : 수집 대상 웹 사이트에 짧은 시간 동안 너무 많은 요청을 보내서는 안된다.
  
- 안정성(robustness) : 비정상적 입력이나 환경에 잘 대응해야 한다.
  
- 확장성(extensibility) : 새로운 형태의 콘텐츠를 지원하기 쉬워야 한다.

## 웹 크롤러 컴포넌트

웹 크롤러의 개략적 설계는 다음과 같다.

![image](https://github.com/user-attachments/assets/0bf98809-4393-4120-b759-6edc955dd6e2)

### 시작 URL 집합

웹 크롤러는 **시작 URL로부터 크롤링을 시작**하며, 이 시작 URL이 여러 개가 존재하면 집합을 이룬다.

전체 웹을 크롤링해야 하는 경우에는 크롤러가 **가능한 많은** 링크를 탐색할 수 있도록 시작 URL을 골라야 한다. 일반적으로는 나라별, 주제별 등의 기준에 의해 전체 URL 공간을 작은 부분집합으로 나누는 전략을 쓴다.

### 미수집 URL 저장소

웹 크롤러는 크롤링 상태를 다운로드할 URL과 다운로드된 URL로 나누어 관리한다. 이 중 **다운로드할 URL을 저장/관리하는 컴포넌트**를 미수집 URL 저장소(URL frontier)라고 한다.

### HTML 다운로더와 도메인 이름 변환기

HTML 다운로더는 **인터넷에서 웹 페이지를 다운로드하는 컴포넌트**다. 다운로드할 페이지의 URL은 미수집 URL 저장소가 제공한다.

HTML 다운로더는 **도메인 이름 변환기**를 사용하여 URL에 대응되는 IP 주소를 알아낸다.

### 콘텐츠 파서

웹 페이지를 다운로드하기 위해 **파싱(parsing)과 검증(validation) 절차**를 거쳐야 하는데, 이를 위해 콘텐츠 파서가 필요하다. 크롤링 서버 안에 콘텐츠 파서를 구현하면 크롤링이 느려지므로 독립된 컴포넌트로 존재한다.

### 콘텐츠 저장소

웹 페이지의 **해시 값**을 비교하여 **이미 시스템에 저장된 콘텐츠인지** 여부를 알아내야 한다.

이때 **HTML 문서를 보관**하는 컴포넌트를 콘텐츠 저장소라고 한다. 저장소를 구현할 때에는 저장할 데이터의 유형, 크기, 저장소 접근 빈도, 데이터 유효 기간 등을 종합적으로 고려해야 한다.

### URL 추출기

URL 추출기는 **HTML 페이지를 파싱하여 링크들을 골라내**는 컴포넌트다. 상대 경로를 절대 경로로 추출하는 작업 등이 있다.

### URL 필터

URL 필터는 특정 콘텐츠 타입이나 파일 확장자를 갖는 URL, 접속 시 오류가 발생하는 URL, 접근 제외 목록에 포함된 URl 등을 **크롤링 대상에서 배제**하는 컴포넌트다.

### 중복 URL 확인

이미 방문한 URL이나 미수집 URL 저장소에 보관된 URL을 추적할 수 있는 자료구조를 사용한다. 이로써 **같은 URL을 여러 번 처리하는 것을 방지**하여 서버 부하를 줄이고 시스템이 무한 루프에 빠지는 일을 방지할 수 있다.

해당 자료 구조로는 블룸 필터(bloom filter)나 해시 테이블이 주로 쓰인다.

### URL 저장소

URL 저장소는 **이미 방문한 URl을 보관**하는 컴포넌트다.

이 시스템 컴포넌트들의 상호 연동 흐름을 살펴보자.

1. 시작 URL들을 미수집 URL 저장소에 저장한다.
   
2. HTMl 다운로더는 미수집 URL 저장소에서 URL 목록을 가져온다.
   
3. HTML 다운로더는 도메인 이름 변환기를 사용하여 URL의 IP 주소를 알아내고, 해당 IP 주소로 접속하여 웹 페이지를 다운받는다.
   
4. 콘텐츠 파서는 다운된 HTML 페이지를 파싱하여 올바른 형식을 갖춘 페이지인지 검증한다.
   
5. 콘텐츠 파싱과 검증이 끝나면 중복 콘텐츠인지 판별한다. 이를 위해 해당 페이지가 이미 저장소에 있는지 확인한다.
    1. 이미 저장소에 있는 경우, 처리하지 않고 버린다.
    2. 저장소에 없는 경우, 저장소에 저장한 뒤 URL 추출기로 전달한다.
       
6. URL 추출기는 해당 HTML 페이지에서 링크를 골라내어 URL 필터로 전달한다.
   
7. URL 필터에서 필터링을 거친 URL에 대해 중복 URL인지 판별한다. 이를 위해 URL 저장소에 보관되어 있는지 확인한다.
    1. 이미 처리한 URL인 경우, 처리하지 않고 버린다.
    2. 저장소에 없는 경우, URL 저장소에 저장하고 미수집 URL 저장소에도 전달한다.

## 가장 중요한 컴포넌트와 구현 기술

### DFS vs BFS

크롤링 프로세스는 edge(URL)를 따라 directed graph(웹)를 탐색하는 과정이다. 이때 DFS는 적합한 기법이 아닌데, 그래프 크기가 클 경우 얼마나 깊게 갈지 가늠할 수 없기 때문이다.

따라서 웹 크롤러는 보통 **BFS**를 사용한다. BFS에서 사용하는 FIFO 큐의 한 쪽으로는 탐색할 URL을 넣고, 다른 한 쪽으로는 이를 꺼낸다. 하지만 여기엔 두 가지 문제점이 있다.

1. 한 페이지에서 나오는 링크의 상당수는 같은 서버로 되돌아간다. 
    
    ![image](https://github.com/user-attachments/assets/2aea0b11-d6ee-4e41-af99-05e02c481d42)
    
    이때 크롤러는 같은 호스트에 속한 많은 링크를 다운받느라 바빠지는데, 링크를 병렬로 처리한다면 서버는 수많은 요청으로 과부하에 걸리게 될 것이다. 이런 크롤러는 보통 예의 없는(impolite) 크롤러로 간주된다.
    
2. 웹 페이지는 페이지 순위(page rank), 트래픽의 양 등에 따라 처리 우선순위가 존재하지만, **표준적 BFS 알고리즘 상으로는 URL 간에 우선순위를 두지 않아** 우선순위를 반영할 수가 없다.

### 미수집 URL 저장소

다운로드할 URL을 보관하는 미수집 URL 저장소를 통해 예의(politeness)를 갖춘 크롤러와 URL 사이의 우선순위 및 신선도(freshness)를 반영하는 크롤러를 구현할 수 있다.

#### 예의

웹 크롤러는 수집 대상 서버로 짧은 시간 안에 너무 많은 요청을 보내는 것을 삼가야 한다. 이는 무례한(impolite) 일이며, 때로는 DoS(Denial-of-Service) 공격으로 간주되기도 한다.

예의 바른 크롤러를 만들기 위해서는 **동일 웹 사이트에 대해서는 한 번에 한 페이지만 요청**하고, 같은 웹 사이트에 대해 여러 번 요청을 보내야 할 경우에는 **시간차**를 두고 실행해야 한다.

이를 만족시키기 위해서는 각 다운로드 스레드가 별도의 FIFO 큐를 가지게 함으로써, 해당 큐에서 꺼낸 URL만 다운로드해야 한다.

![image](https://github.com/user-attachments/assets/192dc280-3acb-42f8-bdca-8109d06212f0)

- 큐 라우터(queue router) : 같은 호스트에 속한 URL은 언제나 같은 큐로 가도록 보장한다.
  
- 매핑 테이블(mapping table) : 호스트 이름과 큐 사이의 관계를 저장한다.
  
- 큐 선택기(queue selector) : 큐들을 순회하며 큐에서 URL을 꺼내 이를 다운로드하도록 지정된 작업 스레드에 전달한다.
  
- 작업 스레드(worker thread) : 전달된 URL을 순차적으로 다운로드하며, 작업들 사이에는 일정한 지연시간을 둘 수 있다.

#### 우선순위

URL의 우선순위를 나눌 때에는 PageRank, 트래픽 양, 갱신 빈도 등 다양한 척도를 사용할 수 있는데, 이때 **순위결정장치**(prioritizer)를 통해 URL 우선순위를 정할 수도 있다.

![image](https://github.com/user-attachments/assets/5527af84-f7a1-4a7e-8027-f9f23b49c44f)

- 순위결정장치(prioritizer) : URL을 입력으로 받아 우선순위를 계산한다.
  
- 큐 : 우선순위별로 큐가 할당되며, 우선순위가 높을수록 선택될 확률도 높아진다.
  
- 큐 선택기 : 임의 큐에서 처리할 URL을 꺼내며, 우선순위가 높은 큐에서 더 자주 꺼낸다.

위 사항들을 모두 반영한 전체 설계는 다음과 같다. 전면 큐에서는 우선순위를 결정하고, 후면 큐에서는 크롤러가 예의 바르게 동작하도록 보증한다.

![image](https://github.com/user-attachments/assets/b593c5b8-6548-44e6-bdab-b414b6271c59)

#### 신선도

웹 페이지는 수시로 추가/삭제/변경되므로 데이터의 신선함(freshness)를 유지하기 위해서는 이미 다운로드된 페이지여도 주기적으로 재수집(recrawl)할 필요가 있다.

그러나 모든 URL을 재수집하는 것은 많은 시간과 자원이 소모되는데, 이를 최적화하기 위해 **웹 페이지의 변경 이력을 활용**하거나, 우**선순위를 기반으로 중요한 페이지를 자주 재수집**할 수 있다.

**미수집 URL 저장소를 위한 지속성 저장장치**

검색 엔진을 위한 크롤러의 경우, 처리해야 하는 URL은 수억 개에 달한다. 이 모두를 메모리에 보관하는 것은 안정성이나 규모 확장성 측면에서 좋지 않고, 그렇다고 모두를 디스크에 보관하는 것도 성능 병목지점이 되기 쉬워 바람직하지 않다.

따라서 **대부분의 URL은 디스크에** 저장하되, I/O 비용을 줄이기 위해 **메모리 버퍼에 큐를** 두는 방식이 좋다.

### HTML 다운로더

#### Robots.txt (Robot Exclusion Protocol)

Robots.txt는 웹사이트가 크롤러와 소통하는 표준 방법으로, 이 파일에는 **크롤러가 수집해도 되는 페이지 목록**이 들어있다. 따라서 크롤러는 웹 사이트를 다운받기 전에 **해당 파일의 규칙을 먼저 확인**해야 한다.

Robots.txt 파일을 불필요하게 다운로드하는 것을 피하기 위해, 이 파일은 **주기적으로 다시 다운되어 캐시에 보관**된다.

#### 성능 최적화

1. **분산 크롤링**

크롤링 작업을 **여러 서버**에 분산하여 성능을 높일 수 있다. 각 서버는 **여러 스레드**를 통해 다운로드 작업을 처리하는데, **URL 공간을 작은 단위로 분할**하여 각 서버가 그 중 일부를 다운로드하는 방식이다.

![image](https://github.com/user-attachments/assets/60c33865-1421-45f3-a78c-cf208b0a4464)

2. **도메인 이름 변환 결과 캐시**

도메인 이름 변환기(DNS Resolver)는 **DNS 요청의 동기적 특성** 때문에 크롤러 성능의 병목 중 하나이다. 크롤러 스레드 중 어느 하나라도 DNS 응답을 기다리고 있으면, 다른 스레드의 DNS 요청은 모두 블록되기 때문이다.

따라서 **DNS 조회 결과로 얻은 도메인 이름과 IP 주소 사이의 관계를 캐시에 보관**해두고, 크론 잡(cron job) 등을 통해 **주기적으로 갱신**시킴으로써 성능을 높일 수 있다.

3. **지역성**

크롤링 서버를 **지역별로 분산**시켜 크롤링 대상 서버들과의 거리를 좁힘으로써 페이지 다운로드 시간을 줄이는 방법이다. (지역성을 활용하는 전략은 크롤링 서버, 캐시, 큐, 저장소 등 대부분의 컴포넌트에 적용 가능하다.)

4. **짧은 타임아웃**

웹 서버가 응답이 느리거나 아예 응답하지 않을 수도 있으므로, **최대 대기 시간을 미리 정해두는** 방법이다. 이 시간 동안 서버가 응답하지 않으면 크롤러는 해당 페이지 다운로드를 중단하고 다음 페이지로 넘어간다.

#### 안정성

1. **안정 해시(consistent hashing)** : 다운로더 서버들에 **부하를 분산**할 때 적용 가능한 기술로, 이를 통해 다운로더 서버를 쉽게 추가 및 삭제할 수 있다.

2. **크롤링 상태 및 수집 데이터 저장** : **크롤링 상태와 수집된 데이터를 영구 저장장치에 저장**해놓음으로써, **장애** 발생 시 이를 로딩하여 **쉽게 복구**할 수 있다.

3. **예외 처리(exception handling) 및 데이터 검증(data validation)**

#### 확장성

새로운 형태의 콘텐츠를 쉽게 지원하기 위해 다음과 같이 PNG 다운로더, 웹 모니터 등의 모듈을 추가할 수 있다.

![image](https://github.com/user-attachments/assets/f866667d-ffee-4d4b-a813-3bbda74bc3af)

#### 문제가 있는 콘텐츠 감지 및 회피 전략

1. **중복 콘텐츠** : 웹 콘텐츠의 30% 가량은 중복이므로, 해시값이나 check-sum 등을 통해 중복 콘텐츠를 검증해야 한다.
   
2. **거미 덫** : 크롤러를 무한 루프에 빠뜨리는 웹 페이지로, 무한히 깊은 디렉토리 구조를 포함하는 링크가 그 예시이다. URL의 최대 길이를 제한하는 등의 방식으로 회피할 수 있다.
   
3. **데이터 노이즈** : 광고, 스팸 URL 등과 같이 가치가 없는 콘텐츠는 크롤링에서 제외해야 한다.

## 추가 논의사항

- 서버 사이드 렌더링 : JS, AJAX 등으로 개발된 웹 페이지를 있는 그대로 파싱해보면 동적으로 생성되는 링크를 발견할 수 없다. 이 문제는 페이지를 파싱하기 전에 서버 사이드 렌더링(동적 렌더링)을 적용하여 해결할 수 있다.
  
- 원치 않는 페이지 필터링 : 크롤링에 소모되는 자원은 유한하므로 스팸 방지 컴포넌트를 통해 필터링하는 것이 좋다.
  
- 데이터베이스 다중화 및 샤딩 / 서버의 수평적 규모 확장성
  
- 데이터 분석 솔루션(analytics)
  
- 가용성, 일관성, 안정성
