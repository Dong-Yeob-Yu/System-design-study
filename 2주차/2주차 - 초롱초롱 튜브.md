# 3장. 시스템 설계 면접 공략법

## 효과적 면접을 위한 4단계 접근법

### 1단계 : 문제 이해 및 설계 범위 확정

요구사항을 완전히 이해하지 않고 섣불리 답을 내놓는 행위는 아주 엄청난 부정적 신호(red flag)이다.

이 단계에서 가장 중요한 것은 **깊이 생각하고 질문함으로써 요구사항과 가정들을 분명히 하는 것**이다. 

요구사항을 정확히 이해하기 위해서는 **올바른 질문**을 하는 것이 중요한데, 구체적으로 다음과 같은 질문을 할 수 있다.

- 구체적으로 어떤 기능을 만들어야 하는지?
  
- 제품 사용자 수는 얼마나 되는지?
  
- 회사의 규모는 얼마나 빨리 커지리라 예상하는지?
  
- 회사가 주로 사용하는 기술 스택(technology stack)은 무엇인지? 설계를 단순화하기 위해 활용할 수 있는 기존 서비스로는 어떤 것이 있는지?

### 2단계 : 개략적인 설계안 제시 및 동의 구하기

이 단계에서 초점을 맞춰야 할 것은 **개략적인 설계안을 제시하고 면접관의 동의를 얻는 것**으로, **면접관과 협력**하여 진행하는 것이 좋다.

1. 설계안에 대한 최초 청사진을 제시하고 면접관의 의견을 구하라.
   
2. 화이트보드나 종이에 핵심 컴포넌트를 포함하는 다이어그램을 그려라.
   
3. 제시한 최초 설계안이 시스템 규모의 제약사항들을 만족하는지를 개략적으로 계산하라.

### 3단계 : 상세 설계

설계 대상 컴포넌트 사이의 **우선순위**를 정해서 중요한 컴포넌트 위주로 설명해야 한다.

**시간 관리**에 유의하여, 불필요한 세부사항에 시간을 쓰느라 설계 능력을 입증할 시간이 부족한 사태가 일어나지 않도록 하자.

### 4단계 : 마무리

설계 결과물에 대해 시스템 병목 구간이나 개선 가능한 지점, 규모 확장 시 대처 방안 등에 대해 생각해두어야 한다.

또한 설계 결과물을 다시 요약하는 것은 면접관의 기억을 환기시키는 효과가 있다.

### 면접 세션에서의 To-Do

문제의 요구사항을 이해해야 하며, 모호하다면 질문을 통해 확인해야 한다.

정답이나 최선의 답안은 없다.

면접관과 소통하라. 면접관에게 나의 사고 흐름을 이해시키고 면접관의 아이디어를 이끌어내라.

가능하다면 여러 해법을 함께 제시하라.

### 면접 세션에서의 Not To-Do

전형적인 면접 문제들에도 대비하지 않은 상태에서 면접장에 가지 말라.

요구사항이나 가정들을 분명히 하지 않은 상태에서 설계를 제시하지 말라.

처음부터 특정 컴포넌트를 너무 세부적으로 설명하지 말라. 개략적 설계를 마친 뒤에 세부사항으로 넘어가라.

소통을 주저하지 말라. 진행 중에 막혔을 때에는 힌트를 요청해라.

### 시간 배분

45분의 시간이 주어진다면 다음과 같은 정도로 시간을 배분하는 것이 좋다.

1단계 : 3~10분

2단계 : 10~15분

3단계 : 10~25분

4단계 : 3~5분

# 4장. 처리율 제한 장치의 설계

네트워크 시스템에서 **처리율 제한 장치**(rate limiter)는 클라이언트 또는 서비스가 보내는 트래픽의 처리율(rate)을 제어하기 위한 장치이다. HTTP 요청, API 요청 등에 적용할 수 있으며, 초당 올릴 수 있는 게시글의 개수가 제한되어있는 경우 등이 이에 해당한다.

API에 처리율 제한 장치를 둔다면 DoS 공격에 의한 자원 고갈 방지, 비용 절감, 서버 과부하 방지 등의 이점을 얻을 수 있다.

## 1단계 : 문제 이해 및 설계 범위 확정

면접관과의 소통을 통해 요구사항을 분명히 하여 어떤 제한 장치를 구현해야 하는지 파악하라.

## 2단계 : 개략적 설계안 제시 및 동의 구하기

기본적인 클라이언트-서버 통신 모델을 사용하는 것이 좋다.

### 처리율 제한 장치의 위치

**클라이언트 측**

일반적으로 클라이언트는 처리율 제한을 안정적으로 처리할 수 없다. 클라이언트 요청은 쉽게 위변조가 가능하며, 모든 클라이언트의 구현을 통제하는 것도 어려울 수 있기 때문이다.

**서버 측**

서버 측에 구현하는 방식은 여러 가지가 존재한다.

- API 서버에 구현
  
- 처리율 제한 미들웨어에 구현 : 처리율 제한을 초과한 요청은 서버에 도착하기 전, 미들웨어에 의해 제한된다.
  
- API 게이트웨이에 구현 : 보편적으로 사용하는 클라우드 마이크로서비스의 경우, 처리율 제한 장치는 **API 게이트웨이**라는 미들웨어에 구현된다.

  API 게이트웨이란 처리율 제한, SSL 종단, 사용자 인증 등을 지원하는, 클라우드 업체가 유지보수를 담당하는 완전 위탁관리형 서비스(fully managed)이다.

→ silver bullet은 없다. 현재 회사의 기술 스택, 우선순위, 현재 설계, 목표 등에 따라 달라진다.

### 처리율 제한 장치의 알고리즘

처리율 제한 장치 구현에는 다양한 알고리즘을 사용할 수 있고 각각은 장단점이 분명하다.

**토큰 버킷 알고리즘** (token bucket)

**버킷 크기**와 **토큰 공급률**을 인자로 받아 이에 따라 토큰 공급 및 요청 처리를 진행한다.

1. 토큰 공급률에 따라 일정 시간마다 토큰이 채워진다. 이때 버킷이 차있다면 버려진다.
 
2. 하나의 요청당 하나의 토큰을 사용한다. 이때 토큰이 없다면 요청은 버려진다.

통상적으로는 API 엔드포인트별로, 또는 IP 주소별로 버킷을 둔다.

장점

- 구현이 쉽고 메모리 효율이 좋다. (이 때문에 인터넷 기업들이 보편적으로 사용하고 있다.)
  
- **짧은 시간에 집중되는 트래픽**에 대해서도 처리 가능하다.

단점

- 버킷 크기와 토큰 공급률을 적절하게 튜닝하는 것이 까다롭다.

**누출 버킷 알고리즘** (leaky bucket)

토큰 버킷 알고리즘과 유사하지만 **요청 처리율이 고정**되어 있다. 보통 **큐**로 구현하며, **버킷 크기**와 **처리율**을 인자로 받는다.

1. 요청이 도착했을 때 큐에 빈 자리가 있으면 요청을 추가한다. 빈 자리가 없다면 요청을 버린다.
   
2. 지정 시간마다 큐에서 요청을 큐에서 꺼내 처리한다.

장점

- 처리율이 고정되므로 **안정적 출력**(stable outflow rate)에 적합하다.

단점

- **짧은 시간에 트래픽이 집중**되어 큐의 요청들을 제때 처리하지 못하면 **최신 요청들이 버려진다**.
  
- 마찬가지로 두 인자를 튜닝하는 것이 까다롭다.

**고정 윈도 카운터 알고리즘** (fixed window counter)

1. 타임라인을 윈도로 나누어 각 윈도에 카운터를 붙인다. 요청이 들어올 때마다 카운터의 값은 1씩 증가한다.
   
2. 카운터 값이 임계치에 도달하면 새 윈도가 열릴 때까지 들어오는 요청들은 버려진다.

장점

- 윈도가 닫히는 시점에 카운터를 초기화하는 방식으로 특정 트래픽 패턴을 처리하기에 적합하다.

단점

- 윈도의 경계 부근에 일시적으로 많은 트래픽이 집중된다면, **기대했던 시스템의 처리 임계치보다** **더 많은** 요청을 처리하게 된다.

**이동 윈도 로그 알고리즘** (sliding window log)

고정 윈도 로그 알고리즘의 문제를 해결한 알고리즘이다.

1. 요청의 타임스탬프를 추적하여 새 요청이 오면 만료된 타임스탬프는 제거하고, 새 요청의 타임스탬프를 로그에 추가한다.
   
2. 로그의 크기가 임계치보다 작거나 같으면 요청을 처리하고, 그렇지 않다면 처리를 거부한다.

장점

- 매우 정교한 처리율 제한 메커니즘으로 인해, **어떤 순간의 윈도를 보더라도 시스템의 처리 임계치를 넘지 않는다.**

단점

- 거부된 요청의 타임스탬프도 보관하기 때문에 메모리를 많이 사용한다.

**이동 윈도 카운터 알고리즘** (sliding window counter)

고정 윈도 카운터 알고리즘과 이동 윈도 로깅 알고리즘을 결합한 형태이다. 다음 식을 통해 현재 윈도의 요청 개수를 도출한다.

`현재 윈도의 요청 개수` = `현재 1분간의 요청 수` + `직전 1분간의 요청 수` * `이동 윈도와 직전 1분이 겹치는 비율`

장점

- 이전 시간대의 평균 처리율에 따라 현재 윈도의 상태를 계산하여 **짧은 시간에 트래픽이 집중되어도 잘 대응**한다.

단점

- 직전 시간대에 요청이 균등하게 분포되어 도착했다고 가정하고 추정치를 계산하기 때문에 **다소 느슨**하다.

### 개략적인 아키텍처

얼마나 많은 요청이 접수되었는지를 추적하는 카운터는 빠르고 시간에 기반한 만료 정책을 지원하는 캐시에 보관하는 것이 적절하다. 주로 레디스(Redis)가 사용된다.

처리율 제한 장치의 개략적인 동작 원리는 다음과 같다.

1. 클라이언트가 처리율 제한 미들웨어에게 요청을 보낸다.
   
2. 처리율 제한 미들웨어는 레디스에서 카운터를 가져와 한도 도달 여부를 검사한다.
   
3. 한도에 도달했다면 요청은 거부되고, 도달하지 않았다면 요청은 API 서버로 전달된다. 이때 미들웨어는 카운터 값을 증가시키고 레디스에 저장한다.

## 3단계 : 상세 설계

개략적 설계에서는 다루지 않았던 처리율 제한 규칙 및 처리가 제한된 요청에 관한 내용을 다룬다.

### 처리율 제한 규칙

처리율 제한 규칙은 보통 설정 파일(configuration file) 형태로 디스크에 저장된다.

```
domain: messaging
descriptors:
	- key: message_type
		Value: marketing
		rate_limit:
				unit: day
				requests_per_unit: 5
```

### 처리율 한도 초과 트래픽의 처리

처리율 제한 장치는 처리율 한도가 초과되면 429(Too many requests) 코드를 **X-Ratelimit-Retry-After 헤더**와 함께 반환한다.

클라이언트는 이 **HTTP 응답 헤더**를 통해 자신의 요청이 처리율 제한에 걸리고 있음을 감지한다.

- X-Ratelimit-Remaining : 윈도 내에 남은 처리 가능한 요청의 수
  
- X-Ratelimit-Limit : 윈도의 요청 처리 한도
  
- X-Ratelimit-Retry-After : 한도 제한이 걸리지 않기 위해 몇 초 뒤에 요청을 보내야 하는지

경우에 따라 한도 제한에 걸린 요청을 나중에 처리하기 위해 버리지 않고 큐에 보관하기도 한다.

### 분산 환경에서의 처리율 제한 기법

단일 서버가 아닌, 여러 대의 서버 및 병렬 스레드를 지원하는 분산 환경에서는 처리율 제한 시 다음 사항들을 고려해야 한다.

**경쟁 조건** (race condition)

병렬 스레드가 레디스의 카운터 값을 동시에 변경할 경우 실제 결과는 올바르게 변경되지 않을 수 있다. 이를 해결하기 위해서는 **락**(lock)을 활용할 수 있지만 이는 시스템의 성능을 상당히 떨어뜨릴 수 있다.

이 경우 **루아 스크립트**(Lua script)와 레디스의 자료구조인 **정렬 집합**(sorted set)을 사용함으로써 해결할 수 있다.

루아 스크립트(Lua script) : 가벼운 명령형/절차적 언어로, 확장 언어로 쓰일 수 있는 스크립팅 언어를 주 목적으로 설계되었다.
Redis에서 이를 사용하면 **여러 명령어를 원자적으로 실행** 가능하고, 스프링 서버와 레디스 서버간의 네트워크 비용을 줄일 수 있다.

정렬 집합(sorted set) : 레디스(Redis)에서 제공하는 Set과 List의 특징을 결합한 자료구조로, 멤버와 score(실수) 쌍으로 이루어져 있으며 score 기준으로 정렬된다.
마찬가지로 Redis에서 **원자적 연산을 지원**하고, 데이터 처리 속도가 빠르다.

**동기화 이슈** (synchronization)

웹 계층의 무상태성으로 인해 클라이언트는 매번 다른 제한 장치로 요청을 보낼 수 있는데, 이때 처리율 제한 장치 서버 간에 동기화를 하지 않는다면 처리율 제한을 적절하게 수행할 수 없다.

해결책으로 **고정 세션**(sticky session)을 활용하여 같은 클라이언트로부터의 요청은 항상 같은 처리율 제한 장치로 보내게 하는 방법이 있지만, 이는 규모 확장성 및 유연성 면에서 좋지 않다.

따라서 **레디스와 같은 중앙 집중형 데이터 저장소**를 쓰는 방식이 권장된다.

**성능 최적화**

**여러 데이터 센터를 지원**하면 각 사용자들과 데이터 센터와의 물리적 거리를 줄임으로써 지연시간(latency)를 감소시킬 수 있다.

제한 장치 간에 데이터를 동기화할 때 최종 일관성 모델(eventual consistency model)을 사용함으로써 시간이 지남에 따라 모든 장치가 결국 일관된 데이터를 가지게 됨을 보장할 수 있다.

**모니터링**

처리율 제한 장치를 설치한 후 채택된 **처리율 제한 알고리즘**과 정의한 **처리율 제한 규칙**이 효과적인지 모니터링함으로써 시스템을 개선할 수 있다.

## 4단계 : 마무리

면접에서 시간적 여유가 있다면 다음 부분도 언급하면 좋다.

- 경성(hard) 또는 연성(soft) 처리율 제한
  
- 다양한 계층에서의 처리율 제한
  
- 처리율 제한을 회피하는 방법/클라이언트를 설계하는 최선의 방법 (캐시를 통해 API 호출 횟수 최소화, 예외 처리 코드 추가 등)
