# 3장

# 효과적 면접을 위한 4단계 접근법

## 1. 문제 이해 및 설계 범위 확정
- **답은 최대한 늦게 제공하라**: 요구사항과 가정을 분명히 한다.
- **올바른 질문을 하기**: 문제의 모호함을 제거하기 위해 질문하라.

## 2. 개략적인 설계안 제시 및 동의 구하기
- **개략적인 설계안 제시**: 초안을 면접관에게 제공한다.
- **동의 구하기**: 설계 방향성에 대해 면접관의 동의를 얻는다.

## 3. 상세 설계
- **중요한 정보에 집중**: 문제에 필요한 핵심 정보만 설명하라.
- **불필요한 세부 내용 생략**: 시간 낭비를 피하라.

## 4. 마무리
- **질문을 통해 확인**: 내가 설계한 시스템이 맞는지 점검하라.
- **요구사항 재확인**: 문제의 요구사항을 다시 점검하라.
- **정답이 없음을 인지**: 최선의 답안이 아니더라도 괜찮다.
- **다양한 해결 방법 제시**: 여러 가능한 대안을 함께 제안하라.

----------

# 4장

# 처리율 제한 장치의 설계

네트워크 시스템에서 처리율 제한 장치는 클라이언트 또는 서비스가 보내는 트래픽의 처리율을 제어하기 위한 장치이다.

## 예시
- 특정 기간 동안 클라이언트가 요청하는 HTTP 요청 횟수를 제한.
- API 요청 횟수가 제한 임계치를 넘으면 추가 호출은 모두 block 처리.

---

## 해당 시스템의 장점
1. **DOS 공격 및 서버 과부하 방지**
    - DOS 공격: 시스템 자원(CPU, 메모리, 네트워크 대역폭 등)을 소진시켜 정당한 사용자의 접근을 차단.
2. **비용 절감**
    - 서버 비용 감소 및 우선순위 높은 API에 더 많은 자원 할당 가능.
    - 서드파티 API 과금 정책에 따라 비용 절감 가능.

---

## 처리율 제한 장치의 위치
1. **클라이언트**
    - **장점**: 없음.
    - **단점**: 데이터 위변조 가능, 다양한 플랫폼에서 일관성 있게 처리하기 어려움.
2. **API 서버**
    - **장점**: API별 요청 조절 가능, 서비스 로직과 통합 용이, 추가 비용 없음.
    - **단점**: 서버 부하 증가, 확장성 부족.
3. **미들웨어**
    - **장점**: API 서버 보호, 역할 분리, 로드밸런싱 환경에서 일관성 유지.
    - **단점**: 세밀한 정책 조절 어려움, 복잡도 증가, 응답 시간 증가.

---

## 처리율 제한 알고리즘

### 1. 토큰 버킷
- **동작 원리**:
    - 지정된 용량의 버킷에 매초 x개의 토큰을 추가.
    - 요청이 들어오면 토큰 1개를 소모. 토큰 부족 시 요청은 버려짐.
- **장점**:
    - 단시간에 몰리는 트래픽에도 유연하게 대응.
- **적용 사례**:
    - API별, IP별 버킷 할당 가능.
- **단점**:
    - 세밀한 조율이 어려움.

---

### 2. 누출 버킷
- **동작 원리**:
    - FIFO 큐로 구현. 요청 도착 시 큐가 가득 차 있으면 요청은 버려짐.
    - 일정 시간마다 큐에서 요청을 꺼내 처리.
- **장점**:
    - 고정된 처리율을 제공하며 메모리 사용이 효율적.
- **단점**:
    - 단시간에 많은 트래픽이 쌓이면 오래된 요청 처리 지연.

---

### 3. 고정 윈도 카운터
- **동작 원리**:
    - 타임라인을 고정된 간격으로 나누고 각 윈도마다 카운터를 붙임.
    - 카운터가 임계치를 넘으면 새 요청은 버려짐.
- **장점**:
    - 구현이 간단하고 메모리 효율이 좋음.
- **단점**:
    - 윈도 경계 부근에서 트래픽이 몰리면 처리 한도를 초과.

---

### 4. 이동 윈도 로깅
- **동작 원리**:
    - 요청의 타임스탬프를 추적. 만료된 타임스탬프 제거.
    - 허용된 요청 개수를 초과하면 요청 거부.
- **장점**:
    - 정교한 처리율 제한 가능.
- **단점**:
    - 많은 타임스탬프를 저장하므로 메모리 사용량 증가.

---

### 5. 이동 윈도 카운터
- **동작 원리**:
    - 고정 윈도와 이동 윈도 로깅을 결합.
    - 이전 시간대와 현재 시간대 요청을 기반으로 처리.
- **장점**:
    - 짧은 시간에 몰리는 트래픽에 적합하며 메모리 효율이 좋음.
- **단점**:
    - 요청 분포를 균등하다고 가정하기 때문에 느슨한 제한 가능.

---

## 개략적인 아키텍처
1. 클라이언트 → 미들웨어로 요청 전송.
2. 미들웨어는 Redis에서 카운터를 가져와 한도 초과 여부 확인.
3. 한도 초과 시 요청 거부, 초과하지 않으면 API 서버로 전달.
4. 카운터 값을 증가 후 Redis에 저장.

---

## 상세 설계

### 처리율 한도 초과 트래픽 처리
1. **429 응답 반환**:
    - 요청 한도 초과 시 클라이언트에 429 상태 코드 반환.
2. **HTTP 응답 헤더**:
    - `X-Ratelimit-Remaining`: 남은 처리 가능 요청 수.
    - `X-Ratelimit-Limit`: 윈도 내 허용된 최대 요청 수.
    - `X-Ratelimit-Retry-After`: 제한을 피하기 위해 요청을 다시 보낼 시간.
3. **요청 큐 처리**:
    - 과부하로 한도 초과된 요청은 큐에 담아 나중에 처리 가능.

---

### 분산 환경에서의 처리율 제한
1. **경쟁 조건 해결**:
    - Redis 락 대신 Lua 스크립트 또는 Redis 자료구조 사용.
2. **동기화 문제 해결**:
    - **고정 세션 방식**: 클라이언트 요청을 항상 같은 서버로 전달.
    - **중앙 집중형 데이터 저장소**: Redis 같은 저장소로 동기화 문제 해결.

