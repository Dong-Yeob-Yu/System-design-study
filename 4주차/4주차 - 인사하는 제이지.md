# 7장 분산 시스템을 위한 유일 ID 생성기 설계
## 설계를 위한 문제 이해 및 설계 범위 확정
* ID는 유일해야 한다.
* ID는 숫자로만 구성되어야 한다.
* ID는 64비트로 표현될 수 있는 값이어야 한다.
* ID는 발급 날짜에 따라 정렬 가능해야 한다.
* 초당 10,000개의 ID를 만들 수 있어야 한다.

## 개략적인 설계안 제시
### 다중 마스터 복제
* DB의 auto_increment 기능을 활용하는 방식
* 다음 ID 값을 구할 때 +1이 아닌 +k만큼 증가시키는 것 (k는 서버 대수)
#### 장점
* ID 값을 숫자로 구성 가능
#### 단점
* scale-out 이 어려움
* 분산된 데이터를 정렬할 때 ID 값을 발급 날짜에 따라 정렬할 수 없음
### UUID
* 위키피디아 "중복 UUID가 1개 생길 확률을 50% 끌어 올리려면 초당 10억 개의 UUID를 100년 동안 계곡 만들어야 한다."
* UUID는 서버 간 조율 없이 독립적으로 생성이 가능하다.
#### 장점
* UUID는 서버 사이의 조율이 필요 없고 단순하다.
* 각 서버가 자기가 쓸 ID를 알아서 만들기 때문에 규모 확장이 쉽다.
#### 단점
* ID가 128비트로 길다. (요구사항: 64비트)
* ID를 시간순으로 정렬할 수 없다. (UUID 버전에 따라 다름)
* ID에 숫자 아닌 값이 포함된다. (요구사항: ID 값에 숫자만 사용 가능)
### 티켓 서버
* 플리커에서 분산 기본 키를 만들어 내기 위해 이 기술을 사용함
* auto_increment 기능을 갖춘 DB 서버(티켓 서버)를 중앙 집중형으로 하나만 사용하는 것
#### 장점
* 유일성이 보장되는 숫자로만 구성된 ID를 쉽게 만들 수 있다.
* 구현하기 쉽고, 중소 규모 애플리케이션에 적합하다.
#### 단점
* 티켓 서버가 단일 SPOF(Single-Point-of-Failure)가 됨
* 서버를 여러 대 준비하게 되면 데이터 동기화같은 새로운 문제가 발생할 것
### 트위터 스노플레이크 접근법
* 트위터가 고안한 독창적인 ID 생성 기법
#### 구조
* sign 비트: 1비트를 할당하며, 음수와 양수를 구별하는데 사용할 수 있다.
* timestamp: 41비트를 할당한다. 기원 시간(epoch) 이후로 몇밀리초가 경과했는지 나타내는 값
* 데이터센터 ID: 5비트. 2^5인 32개의 데이터센터를 지원할 수 있다.
* 서버 ID: 5비터. 데이터센터당 32개의 서버를 사용할 수 있다.
* 일련번호: 12비트 할당. 각 서버에서는 ID를 생성할 때마다 이 일련번호를 1만큼 증가시킨다. 이 값은 1밀리초가 경과할 때마다 0으로 초기화

## 상세 설계
* 목적에 부합하는 스노플레이크 기술을 기반으로 상세 설계함
### 데이터센터 ID, 서버 ID
* 데이터센터 ID나 서버 ID는 시스템이 시작될 때 결정되며, 일반적으로 시스템 운영 중에는 변경되지 않음
* 데이터센터 ID나 서버 ID를 잘못 변경하게 되면 ID 충돌이 발생할 수 있기 때문에 신중해야 함
### 타임스탬프
* 41비트이기 때문에 최대 69년의 시각을 표현할 수 있음
* 트위터는 epoch을 최대한 현재에 가깝게 맞춰서 오버플로가 발생하는 시점을 늦춰 놓았음
* 69년이 지나면 epoch을 바꾸거나 ID 체계를 다른 것으로 이전해야 함

### 일련번호
* 12비트이기 때문에 한 서버당 하루에 최대 4096개의 ID를 생성할 수 있음

## 마무리
### 시계 동기화
* ID 생성 서버들이 전부 같은 시계를 사용한다고 가정하였음
* 하지만 하나의 서버가 여러 코어에서 실행될 경우 유효하지 않을 수 있음
* 여러 서버가 물리적으로 독립된 여러 장비에서 실행되는 경우에도 마찬가지
* NTP(Network Time Protocol)이 이런 문제를 해결하는 보편적인 수단
  * 같은 네트워크 상에 있는 서버들끼리 시간을 동기화하는 프로토콜
  * NTP 서버를 통해서 0.001초 오차 이내로 시간을 동기화함 (UDP 기반)
### 각 절의 길이 최적화
* 동시성이 낮고 수명이 긴 애플리케이션이라면 일련번호 절의 길이를 줄이고 타임스탬프 길이를 늘리는 것이 효과적일 수 있다.
### 고가용성
* ID 생성기는 필수 불가결 컴포넌트이므로 높은 가용성이 필요함
# 8장 URL 단축키 설계
## 설계를 위한 문제 이해 및 설계 범위 확정
### 기능 요구사항
* URL 단축: 주어진 URL을 훨씬 짧게 줄인다.
* URL 리디렉션: 축약된 URL로 HTTP 요청이 오면 원래 URL로 안내
* 높은 가용성과 규모 확장성, 그리고 내결함성이 요구됨
### 개략적 추정
* 쓰기 연산: 매일 1억 개의 단축 URL 생성
* 초당 쓰기 연산: 1억/24/3600 = 1160
* 읽기 연산: 읽기 연산과 쓰기 연산의 비율은 10:1이라고 하자. 그 경우 읽기 연산은 초당 11,600회 발생한다.
* URL 단축 서비스를 10년간 운영한다고 가정하면 1억 * 365 * 10 = 3650억 개의 레코드를 보관해야 한다.
* 축약 전 URL의 평균 길이는 100이라고 하자
* 따라서 10년 동안 필요한 저장 용량은 3650억 * 100바이트 = 36.5TB
## 개략적인 설계안 제시
### API 엔드포인트
* URL 단축용 엔드포인트 설계
  * POST /api/v1/data/shorten
  * 인자: {longUrl: longURLstring}
  * 반환: 단축 URL
* URL 리디렉션용 엔드포인트 설계
  * GET /api/v1/shortUrl
    * 반환: HTTP 리디렉션 목적지가 될 원래 URL
    * requestParam이나 path에 단축 URL이 들어가야 할 거 같은데 책에 안 보임
### URL 리디렉션
* 원래 URL = hashTable.get(단축 URL)
* 301 또는 302 응답 Location 헤더에 원래 URL을 넣은 후 전송

![리디렉션](https://cdn-images-1.medium.com/max/800/1*Za-iyq6jtDDWP--yBHeNTw.png)

* 301 Permanently Moved
  * 해당 URL에 대한 HTTP 요청의 처리 책임이 영구적으로 Location 헤더에 반환된 URL로 이전되었다는 응답
  * 브라우저는 이 응답을 캐시함
  * 부하를 줄이기 위해서는 301이 유리함
* 302 Found
  * 이 응답이 주어진 URL로의 요청이 일시적으로 Location 헤더가 지정하는 URL에 의해 처리되었다는 응답
  * 트래픽 분석을 위해서는 302가 유리함 (클릭 발생률이나 발생 위치 추적 등)

### URL 단축
* 단축 URL이 `www.tinyurl.com/{hashValue}` 값은 형태라고 할 경우, 긴 URL을 이 해시 값으로 대응시킬 해시 함수 fx를 찾는 일이 중요함

## 상세 설계
### 데이터 모델
* 비용과 안정성을 생각하여 <단축 URL, 원래 URL> 쌍을 DB에 저장하는 형태로 가는 것이 좋음
* id, shortURL, longURL 필드를 갖는 테이블을 생성함

### 해시 함수
#### 해시 값 길이
* hashValue는 [0-9a-zA-Z]의 문자들로 구성된다. 따라서 사용할 수 있는 문자의 개수는 62개.
* hashValue의 길이를 정하기 위해서는 62^n >= 3650억인 n의 최소값을 찾아야 함
* n이 7이면 3.5조의 URL을 만들 수 있음
#### 해시 후 충돌 해소
* CRC32, MD5, SHA-1 등의 해시 함수를 사용하는 것이 일반적
* 가장 짧은 결과물을 만들어내는 CRC32도 목표했던 7보다 길이가 김
* 계산된 해시값에서 처음 7글자만 사용하고 충돌할 경우, 충돌이 해소될 때까지 사전에 정한 문자열을 해시에 덧붙이는 식으로 구현
* 충돌은 해소살 수 있지만 충돌이 있을 때마다 DB 접속을 해야 하기 때문에 오버헤드가 큼
* 블룸 필터를 쓰면 좀 더 완화할 수 있음

#### base62 변환
* ID 값을 62진법으로 변환하여 hashValue 만들기

#### 두 접근법 비교
| 해시 후 충돌 해소 전략                                           | base-62 변환                                                                  |
|---------------------------------------------------------|-----------------------------------------------------------------------------|
| 단축 URL의 길이가 고정됨 (충돌하면 길이가 길어지는거 아닌가?)                   | 단축 URL의 길이가 가변적, ID 값이 커지면 같이 길어짐                                           |
| 유일성이 보장되는 ID 생성기가 필요치 않음                                | 유일성 보장 ID 생성기가 필요함                                                          |
| 충돌이 가능해서 해소 전략이 필요                                      | ID의 유일성이 보장된 후에야 적용 가능한 전략이라 충돌 발생하지 않음                                     |
| ID로부터 단축 URL을 계산하는 방식이 아니라서 다음에 쓸 수 있는 URL을 알아내는 것이 불가능 | ID가 1씩 증가하는 값이라고 가정하면 다음에 쓸 수 있는 단축 URL이 무엇인지 쉽게 알아낼 수 있어서 보안상 문제가 될 소지가 있음 |

### URL 단축기 상세 설계
1. 입력으로 긴 URL을 입력받음
2. DB에 해당 URL이 있는지 검사
3. DB에 있다면 매핑된 단축 URL 반환
4. DB에 없을 경우 유일한 ID를 생성한다.
5. 62진접 변환을 적용, ID를 단축 URL로 만든다.
6. ID, 단축 URL, 원래 URL로 새 레코드를 만들고 단축 URL 반환

### URL 리디렉션 상세 설계
* 서버에 캐시를 붙여서 성능 향상
1. 사용자가 단축 URL을 클릭
2. 로드밸런서가 해당 클릭으로 발생한 요청을 웹 서버에 전달
3. 단축 URL이 캐시 히트될 겨우 곧바로 클라이언트에 전달
4. 캐시 미스일 경우 DB에서 데이터를 읽어서 캐시에 적재
5. 적재된 긴 URL 반환

## 마무리
### rate-limiter
* 엄청난 양의 URL 단축 요청이 밀려들 경우 무력화될 수 있음
* rate-limiter를 두고, IP 주소를 비롯한 필터링 규칙을 정희하면 대응할 수 있음
### 웹 서버의 규모 확장
* 웹 계층은 무상태로 설계되어 웹 서버 증설과 삭제가 용이함
### DB 규모 확장
* DB를 다중화하거나 샤딩하여 규모 확장성을 달성할 수 있다.
### 데이터 분석 솔루션
* URL 단축기에 데이터 분석 솔루션을 통합해 두면 어떤 링크를 얼마나 많은 사용자가 클릭했는지, 언제 클릭했는지 등의 정보를 수집할 수 있음
### 가용성, 데이터 일관성, 안정성
* 대규모 시스템이 성공적으로 우녕되기 위해 필요한 필수 속성