# 7장. 분산 시스템을 위한 유일 ID 생성기 설계

데이터베이스 서버가 여러 대인 분산 시스템에서 유일성이 보장되는 ID를 생성하는 방법들을 살펴보자.

이번 장에서 ID가 만족시켜야 하는 특성은 다음과 같다고 가정하자.

> ID는 유일해야 한다.
> 
> ID는 숫자로만 구성되어야 한다.
> 
> ID는 64비트로 표현될 수 있는 값이어야 한다.
> 
> ID는 발급 날짜에 따라 정렬 가능해야 한다.
> 
> 초당 10,000개의 ID를 만들 수 있어야 한다.

## 다중 마스터 복제 (multi-master replication)

데이터베이스의 **auto_increment**를 활용하는 방법인데, 다음 ID를 구할 때 1이 아닌 **k만큼 증가**시킨다는 점이 다르다. 여기서 k는 현재 사용 중인 데이터베이스 서버의 개수이다.

장점

- 데이터베이스 서버 개수를 늘리면 초당 생산 가능 ID 수도 늘릴 수 있어, 규모 확장성 문제를 어느 정도 해결할 수 있다.

단점

- 여러 데이터 센터에 걸쳐 규모를 늘리기 어렵다.
  
- ID의 유일성은 보장되지만 ID 값이 시간이 흐름에 따라 커지는 것을 보장할 수는 없다.
  
- 서버를 추가 또는 삭제할 때에도 잘 동작하게 만들기 어렵다.

## UUID (University Unique Identifier)

UUID란 컴퓨터 시스템에 저장되는 정보를 유일하게 식별하기 위한 128비트짜리 수로, **UUID 값은 충돌 가능성이 매우 낮다**.

장점

- UUID는 서버 간의 조율 없이 **독립적으로** 생성 가능하므로 단순하고 동기화 이슈가 없다.
  
- 각 서버가 자기가 사용할 ID를 각자 생성하는 구조이므로 규모 확장 또한 쉽다.

단점

- 128비트로 굉장히 길며, 숫자가 아닌 값이 포함될 수도 있다.
  
- 시간순으로 정렬할 수 없다는 점이 ID로 사용하기에 부적합할 수 있다.

## 티켓 서버 (ticket server)

auto_increment를 갖춘 데이터베이스 서버, 즉 **티켓 서버**를 **중앙 집중형**으로 하나만 사용하는 방법이다.

분산 기본 키(distributed primary key)를 만들기 위해 티켓 서버를 활용할 수 있다.

장점

- 유일성이 보장되는, 오직 숫자로만 구성된 ID를 쉽게 만들 수 있다.
  
- 구현이 쉬우며, 중소 규모 애플리케이션에 적합하다.

단점

- 티켓 서버가 **SPOF**가 된다. 이를 피하기 위해서는 여러 대의 티켓 서버가 필요한데, 이에 따라 동기화와 같은 새로운 문제가 발생한다.

## 트위터 스노플레이크(twitter snowflake) 접근법

트위터에서 고안한 방법으로, 분할 정복 전략(divide and conquer)을 적용하여 생성해야 하는 ID의 구조를 **여러 section으로 분할**하는 방법이다.

이를 사용하면 모든 요구사항을 만족시키면서 규모 확장이 가능하다.

![image](https://github.com/user-attachments/assets/db093eea-1bd0-4e4b-9f14-ef697fec0176)

- 타임스탬프(timestamp) : 41비트를 차지하며, epoch time 이후로 경과한 밀리초를 나타낸다.
  
- 데이터센터 및 서버 ID (instance)
  
- 일련번호(sequence) : 12비트를 차지하며, 각 서버에서 ID 생성 시 이 일련번호를 1씩 증가시키고 1밀리초가 경과할 때마다 0으로 초기화된다.

데이터센터 및 서버 ID는 시스템이 시작할 때 결정되어 일반적으로 운영 중에는 변하지 않는다. 반면 타임스탬프나 일련번호는 ID 생성기가 실행 중에 동적으로 생성되는 값이다.

### 타임스탬프

시간이 흐름에 따라 타임스탬프는 점점 커지므로, 결국 ID는 **시간 순으로 정렬 가능**하게 된다.

위의 ID 구조에서 timestamp를 나타내는 41비트를 십진수로 변환 후 epoch time을 더함으로써 UTC 시각을 추출할 수 있다. 

41비트로 표현할 수 있는 타임스탬프의 최댓값에 따라 해당 ID 생성기는 **69년 동안 정상 동작**한다. 따라서 69년이 지나면 기원 시각을 바꾸거나 ID 체계를 이전(migration)해야 한다.

### 일련번호

일련번호는 12비트이므로, $2^{12}$(4096)개의 값을 가질 수 있다. 특정 서버가 1 밀리초 이내에 하나 이상의 ID를 생성한 경우에 한해 0보다 큰 값을 갖는다.

## 추가 논의 사항

- 시계 동기화(clock synchronization) : 하나의 서버가 여러 코어에서 실행되거나 물리적으로 독립된 장비에서 실행되는 경우, ID 생성 서버들이 각각 다른 clock을 사용할 것이다. 보편적으로 NTP(Network Time Protocol)로 이를 해결할 수 있다.
  
- 각 section의 길이 최적화 : 애플리케이션의 동시성 정도, 수명 등에 따라 일련번호 및 타임스탬프 section의 길이를 조절하여 최적화할 수 있다.

- 고가용성(high availability) : 필수적인 컴포넌트로 아주 높은 가용성이 필요하다.

# 8장. URL 단축기 설계

이번 장에서 단축 URL과 관련하여 제공해야 하는 기능은 다음과 같다고 가정하자.

> URL 단축 : 주어진 긴 URL을 훨씬 짧게 줄인다.
> 
> URL 리디렉션(redirection) : 축약된 URL로 HTTP 요청이 오면 원래 URL로 안내한다.
> 
> 높은 가용성과 규모 확장성, 장애 감내

## 개략적 설계

### API 엔드포인트

클라이언트는 서버가 제공하는 API 엔드포인트를 통해 서버와 통신하는데, 이번 장에서는 REST 스타일로 설계해볼 것이다.

URL 단축기는 기본적으로 두 개의 엔드포인트를 필요로 한다.

1. **URL 단축용 엔드포인트** : 단축 URL을 생성하기 위해 클라이언트는 이 엔드포인트로 **단축할 URL을 인자로** 담아 POST 요청을 보내야 한다.
    
    ```
    POST /api/v1/data/shorten
    ```
    
    - 인자 : `{longUrl: longURLstring}`
    - 반환 : 단축 URL
    
2. **URL 리디렉션용 엔드포인트** : **단축 URL에 대해 HTTP 요청이 왔을 때, 원래 URL로 보내주는** 엔드포인트이다.
    
    ```
    GET /api/v1/shortUrl
    ```
    
    - 반환 : HTTP 리디렉션 목적지가 될 원래 URL

### URL 리디렉션

단축 URL을 받은 서버는 이를 원래 URL로 바꾸어 301 응답의 Location 헤더에 넣어 클라이언트에게 반환한다.

![image](https://github.com/user-attachments/assets/1cb85f2b-7ae5-42ba-9f83-68aa48174ce3)

이때 301 응답과 302 응답의 차이를 유의해야 한다. 두 응답은 명확한 차이가 있으므로 상황에 맞게 사용하면 된다.

- 301 Permanently Moved : 해당 URL로의 HTTP 요청이 **영구적으로** Location 헤더의 URL에서 처리된다는 응답이다.

  브라우저는 응답으로 받은 원본 URL을 캐싱하여 추후 같은 단축 URL로 요청을 보낼 때 사용한다.
  
- 302 Found : 해당 URL로의 HTTP 요청이 **일시적으로** Location 헤더의 URL에서 처리된다는 응답이다.

  클라이언트의 요청은 언제나 단축 URL 서버에 먼저 전송된 후 원본 URL로 리디렉션되어야 한다.

서버 부하 측면에서는 첫 번째 요청만 단축 URL로 전송되는 301 Permanent Moved가, 트래픽 분석 측면에서는 클릭 발생률 등을 추적하기 쉬운 302 Found가 유리하다.

**해시 테이블**을 사용함으로써 URL 리디렉션을 직관적으로 구현할 수 있다. <단축 URL, 원본 URL>의 쌍을 저장한다면 다음과 같이 구현할 수 있다.

> 원래 URL = hashTable.get(단축 URL)
> 
> 301 또는 302 응답 Location 헤더에 원본 URL을 추가하여 전송

### URL 단축 플로우

URL을 단축시키기 위해서는 긴 원본 URL을 해시 값으로 대응시킬 **해시 함수**를 찾는 것이 중요하다. 이때 해시 함수는 다음을 만족해야 한다.

> 입력으로 주어지는 긴 URL이 **다르다면** 해시 값도 **달라야** 한다.
>
> 계산된 해시 값은 원래 입력으로 주어졌던 긴 URL로 **복원될 수 있어야 한다.**

## 구체적 설계

개략적 설계에서 모든 데이터를 해시 테이블에 저장했지만, 메모리는 비용이 크므로 이는 실제 시스템에 적용하기 어렵다. 더 나은 방법은 **<단축 URL, 원래 URL>의 순서쌍을 관계형 데이터베이스에 저장**하는 것이다.

### 해시 함수

원본 URL을 단축 URL로 변환할 때 해시 함수를 사용한다. 앞으로 해시 함수가 계산하는 단축 URL을 hashValue라고 하자.

hashValue는 [0-9, a-z, A-Z]의 총 62개의 문자들로 구성된다.

$62^{n}$ ≥ {만들어낼 수 있어야 하는 URL의 갯수}를 만족시키는 n의 **최솟값**이 바로 **hashValue**의 길이이다.

해시 함수 구현에 쓰일 기술로는 해시 후 충돌 해소 방법과, base-62 변환 방법이 있다.

#### 해시 후 충돌 해소 방법

SHA-1과 같이 잘 알려진 해시 함수를 사용하는 것이다. 만약 계산한 가장 짧은 해시값조차 hashValue의 길이보다 길다면, 해시 값에서 **처음 7개의 글자만 이용**함으로써 단축할 수 있다.

그러나 해시 결과가 충돌할 확률이 높아지는데, 이 경우 **충돌이 해소될 때까지 사전에 정한 문자열을 해시값에 덧붙**인다.

이에 따르면 충돌은 해소할 수 있지만 단축 URL 생성 시마다 발생하는 DB 질의로 인해 **오버헤드가 큰**데, 이는 **블룸 필터**를 사용함으로써 성능을 높일 수 있다.

#### base-62 방법

보편적으로 사용하는 방법으로, 수의 표현 방식이 다른 두 시스템이 같은 수를 공유해야 하는 경우에 유용하다.

hashValue에 사용할 수 있는 문자가 62개이므로 10진수를 **62진수**로 변환한다.

| 해시 후 충돌 해소 전략 | base-62 변환 |
| --- | --- |
| 단축 URL 길이가 고정됨 | 단축 URL 길이가 가변적임 (ID 값이 커지면 길어짐) |
| 유일성이 보장되는 ID 생성기가 필요하지 않음 | 유일성이 보장되는 ID 생성기가 필요함 |
| 충돌 가능성이 있으므로 해소 전략 필요 | ID의 유일성이 보장된 후에야 적용 가능하므로 충돌 가능성 없음 |
| ID로부터 단축 URL을 계산하지 않으므로 다음에 쓸 수 있는 URL을 알아낼 수 없음 | ID의 증가 전략에 따라 다음에 쓸 수 있는 URL을 알아낼 수 있어, 보안상 문제가 발생할 수도 있음 |

### URL 단축기 상세 설계

URL 단축기의 처리 흐름을 살펴보자.

1. 입력으로 긴 URL을 받는다.
   
2. 데이터베이스에 해당 URL이 있는지 확인한다.
   
3. 데이터베이스에 있다면 해당 URL에 대한 단축 URL을 가져와 클라이언트에게 반환한다.
   
4. 데이터베이스에 없다면 새로운 ID를 생성한다. 이 ID는 데이터베이스의 기본 키로 사용된다.
   
5. base-62 방법을 통해 **ID**를 단축 URL로 변환한다.
   
6. ID, 단축 URL, 원래 URL로 새 데이터베이스 레코드를 만든 후 단축 URL을 클라이언트에게 반환한다.

이때 ID 생성기가 생성한 ID는 **전역적 유일성**(globally unique)이 보장되어야 한다.

### URL 리디렉션 상세 설계

URL 리디렉션 메커니즘을 살펴보자.

1. 사용자가 단축 URL을 클릭한다.
   
2. 로드밸런서가 해당 클릭으로 발생한 요청을 웹 서버에 전달한다.
   
3. 단축 URL이 이미 캐시에 있다면 이를 클라이언트에게 반환한다.
   
4. 단축 URL이 캐시에 없다면 데이터베이스에서 가져와 캐시에 넣은 후 클라이언트에게 반환한다.

## 추가 논의사항

- 처리율 제한 장치(rate limiter) : **필터링 규칙**(filtering rule)을 이용해 엄청난 양의 URL에 대한 요청을 걸러낼 수 있다.
  
- 웹 서버 또는 데이터베이스의 규모 확장 : 웹 계층이 무상태(stateless) 계층이라면, 웹 서버를 자유롭게 추가/제거할 수 있다. 또한 데이터베이스 다중화 또는 샤딩을 통해 데이터베이스를 추가할 수 있다.
  
- 데이터 분석 솔루션(analytics) : URL 단축기에 데이터 분석 솔루션을 통합해두면 링크 클릭율 등의 비즈니스를 위한 데이터들을 수집할 수 있다.
