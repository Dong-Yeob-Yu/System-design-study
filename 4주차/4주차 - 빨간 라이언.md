# 7주차

# 분산 시스템을 위한 유일 ID 생성기 설계

- 분산 시스템에서 사용될 유일 ID 생성기를 설계 할때 auto_increment 속성은 분산환경에서 통하지도 않고 데이터베이스 서버 한대로는 그 요구를 감당할수 없고, 여러 DB를 사용할 경우 지연 시간을 낮추기가 무척 힘들다.

---

## 분산 시스템에서 유일성이 보장되는 ID 만드는 방법

- 다중 마스터 복제 : 데이터베이스의 auto_increment 기능을 활용하는 것이며, 다음 ID를 구하는 방식은 1이 아니라 k 이다, 만약 서버가 2대라면 1, 3, 5 … 식으로 증가하게된다.
    - 단점 : 규모를 늘리기 힘들다, ID의 유일성은 보장되겠지만 시간 순으로 정렬은 보장할 수 없다.


- UUID : 128비트짜리 수의 유일성이 보장되는 키 생성방법이다.
    - 장점 : UUID를 만드는 방법은 단순하다, 서버 사이의 조율이 필요 없으므로 동기화 이슈도 없다, 규모 확장도 쉽다.
    - 단점 : ID가 128비트이므로 요구사항인 64비트를 충족하지 못한다, 시간순으로 정렬할 수 없다, ID에 숫자가 아닌 문자도 포함이 된다.


- 티켓서버 : auto_increment 기능을  사용하는 데이터베이스를 중앙 집중형으로 사용하는 방법이다.
    - 장점 : 구현하기 쉽고 작은 규모의 서비스에 적합하다, 유일성이 보장되는 숫자로만 구성된 ID를 쉽게 만들 수 있다.
    - 단점 : 티켓서버가 단일 실패 지점(Single Point of Failure)가 되므로 티켓서버에 장애가 발생하면 모든 시스템이 영향을 받는다. 이 이슈를 피할려면 티켓 서버를 여러 대 준비해야하는데 이러면 데이터 동기화 같은 새로운 문제가 발생하게 된다.


- 트위터 스노플레이크 : ID의 구조가 여러절(section) 으로 분할 되어있다.
    1. 사인 비트 (1bit) → 음수와 양수를 구분하는데 사용한다, 해당 절에선 사용하지않음
    2. 타임스탬프 (41bit) → 타임스탬프를 이용하여 구한다. 기원시각으로 부터 몇 밀리초가 경과했는지 나타냄
    3. 데이터센터ID (5bit) → 2^5 개의 데이터센터를 지원할 수 있다. (32개)
    4. 서버ID (5bit) → 2^5 개의 서버를 지원할 수 있다. (32개)
    5. 일련번호 (12bit) → 각 서버에서 ID를 생성할때마다 일련번호를 1만큼 증가시킨다. 이 값은 1밀리초가 경과할 때마다 0으로 초기화 된다.

----

----

# 8장

# URL 단축키 설계

- URL 단축키 설계는 고전적인 시스템 설계 문제이다. 기본적 기능은 아래와 같다.
1. URL 단축 : 주어진 긴 URL을 짧게 줄인다.
2. URL 리디렉션(redirection) : 축약된 URL로 HTTP 요청이 오면 원래 URL로 안내
3. 높은 가용성과 규모 확장성, 그리고 장애 감내가 요구됨


## 엔드포인트

- URL 단축기는 기본적으로 2개의 엔드포인트를 필요로 한다.
1. URL 단축용 엔드포인트 : 단축할 URL을 인자로 담아 요청을 보낸다 → 단축된 URL 반환
2. URL 리디렉션용 엔드포인트 : 단축 URL에 대해서 요청이 오면 원래 URL을 보내준다.


## URL 리디렉션

- 단축 URL을 받은 서버는 단축 URL을 기존 URL로 바꾸고 301 응답과 Location 헤더에 URL을 담아 반환한다.
- 301 Permanently Moved : 이 응답은 해당 URL에 대한 HTTP 요청의 처리 책임이 ‘영구적으로’ Location 헤더에 반환된 URL로 이전되었다는 응답이다. 영구적으로 이전되었으므로 ‘브라우저’는 이 응답을 캐시한다.
- 302 Found : 이 응답은 주어진 URL로의 요청이 ‘일시적으로’ Location 헤더가 지정하는 URL에 의해 처리되어야 한다는 응답이다.
    - 301 응답의 장점 : 서버 부하를 줄일 수 있다.
    - 302 응답의 장점 : 트래픽 분석이 중요하다면(클릭 발생률, 발생 위치 추적 등) 유리하다.


## URL 단축

- 중요한건 긴 URL을 해시값으로 대응시킬 함수를 찾는 일이다.
- 해시 함수는 2가지 요구사항을 만족해야한다.
    1. 입력으로 주어진 긴 URL이 다른 값이면 해시 값도 달라야한다.
    2. 계산된 해시 값은 원래 입력으로 주어졌던 긴 URL로 복원될 수 있어야한다.


# 상세 설계

- 개략적으로 설계할땐 모든 것을 해시 테이블에 두었다. 이 접근법은 초기 전략으로는 괜찮지만 실제 시스템에 쓰기에는 곤란하다, 메모리는 유한하고 비싸기 때문이다. 더 나은 방법은 단축 URL, 원래 URL 의  순서쌍을 RDB에 저장하는 것이다


## 해시함수

- 해시 함수는 원래 URL을 단축 URL로 변환하는데 쓰인다. 요구사항에선 [0-9, a to z, A to Z] 의 문자들로 구성되며 총 62개의 문자이며 요구사항으로 최대 3650억개의 URL을 만들 수 있어야한다.
- 62^7은 약 3.5조 이며 요구사항 갯수를 만족시키기에 충분한 값이다. 이로써 총 7글자의 해시값을 쓸 수 있다.
- 해시 함수 구현엔 2가지 방법이 있다.
    1. 해시 후 충돌 해소 : 잘 알려진 해시함수 (CRC32, MD5, SHA-1) 등을 이용해서 해시값을 만들어낸다. 여기서 가장 해시 길이가 짧은 CRC32 같은 경우 7글자 보다 길다. 이럴땐 계산된 해시 값에서 처음 7 글자만 이용한다. 이렇게 하면 충돌할 확률이 높아지는데 충돌이 발생하면 충돌이 해소될 때까지 사전에 정한 문자열을 해시값에 덧붙힌다.
        - 단점 : URl을 생성할때 DB를 1번 이상 태워야하므로 오버헤드가 크다. 이 방법은 블룸 필터로 성능을 높힐 수 있다.
    2. base-62 변환 : 유일성 보장 ID 생성기가 필요, ID가 유일하므로 충돌은 아예 불가능


## 추가적으로 고려할 수 있는 사항

- 처리율 제한 장치
- 웹 서버의 규모 확장
- 데이터베이스의 규모 확장
- 데이터 분석 솔루션
- 가용성, 데이터 일관성, 안전성