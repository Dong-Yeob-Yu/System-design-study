# 13장 검색어 자동완성 시스템

## 문제 이해 및 설계 범위 확정
### 요구사항
* 빠른 응답 속도: 0.1ms 이내 응답
* 연관성: 출력되는 검색어는 사용자가 입력한 단어와 연관돠어야 함
* 정렬: 시스템의 계산 결과는 인기도의 순위 모델로 정렬되어야 함
* 규모 확장성: 트래픽을 감당할 수 있어야 함
* 고가용성: 시스템 일부에 장애가 발생해도 사용 가능해야 함
### 개략적 규모 추산
* 일간 능동 사용자는 10,000,000명
* 평균적으로 한 사용자는 매일 10건의 검색 수행
* 질의할 때 평균적으로 20바이트의 데이터를 입력함
* 사용자가 검색창에 글자를 입력할 때마다 백엔드에 요청한다.
  * ex) dinner를 입력하면 총 6번의 요청이 호출됨
* 대략 초당 24,000 건의 QPS가 발생하게 됨
* 최대 QPS는 24,000 * 2 = 48,000
* 질의 가운데 20% 정도는 신규 검색어라고 가정.
  * 대략 0.4GB의 신규 데이터가 DB에 생성됨
## 개략적 설계안 제시 및 동의 구하기
### 데이터 수집 서비스
* 질의문과 사용빈도를 저장하는 빈도 테이블에 검색어와 빈도를 저장
### 질의 서비스
* 규모가 작을 때는 간단한 DB 쿼리로 해결할 수 있으나 규모가 커지면 DB가 병목이 될 수 있음
## 상세 설계
### 트라이(Trie) 자료구조
#### 트라이
* 트리 형태의 자료구조
* 루트 노드는 빈 문자열
* 각 노드는 글자 하나를 저장하며, 뒤이어 등장할 수 있는 모든 문자를 자식 노드로 가질 수 있다.
* 각 트리 노드는 하나의 단어 또는 접두어 문자열을 나타낸다.
* 정렬을 위해 빈도 정보도 저장되어야 함
#### 트라이 관련 용어
* p: 접두어의 길이
* n: 트라이 안에 있는 노드 개수
* c: 주어진 노드의 자식 노드 개수
#### 가장 많이 사용된 질의어 k개 찾기
* 해당 접두어를 표현하는 노드를 찾는다. 시간복잡도 O(p)
* 해당 노드부터 시작하는 하위 트리를 검색하여 모든 유효 노드를 찾는다. O(c)
* 유효 노드들을 정렬하여 가장 인기 있는 검색어 k개를 찾는다. O(c * log c)
* 전체 시간 복잡도는 O(p) + O(c) + O(c * log c)
* 최악의 경우 trie 전체를 전부 검색하게 됨
#### trie 최악 케이스 회피
##### 접두어 최개 길이를 제한
* 사용자가 검색창에 긴 검색어를 입력하는 경우는 거의 없기 때문에 검색어 최대 길이를 제한함
* 검색어 최대 길이를 제한하게 되면 접두어 표현을 찾는 단계의 시간 복잡도는 작은 상수 시간으로 제한 가능
##### 각 노드 인기 검색어 캐시
* 각 노드의 인기 검색어를 캐싱하여 응답 속도를 현저히 줄일 수 있음
* 대신 메모리를 희생해야 함
* 근데 캐싱 전략이 중요할 것으로 보이는데?
##### 종합
* 두 가지 기법을 통해서 결국 종합적으로 O(1)의 성능을 낼 수 있음

### 데이터 수집 서비스
* 유저가 타이핑할 때마다 트라이를 수정하게 되면 서비스 성능이 저하될 것
* 트라이가 만들어지면 검색어가 그다지 자주 바뀔 일 없을 것이기 때문에 자주 갱신할 필요없음
#### 데이터 분석 서비스 로그
* 검색창에 입력된 질의에 관한 원본 데이터가 보관됨
#### 로그 취합 서버
* 데이터 분석 서비스로부터 나오는 로그를 소비하기 쉽게 aggregation 해야 함
* 실시간성 요구 사항에 따라 설계가 달라질 수 있음
#### 취합된 데이터
* 로그 취합 서버에서 취합된 데이터로 날짜, 단어, 빈도로 구성됨
#### 작업 서버
* 트라이 자료구조를 만들고 데이터베이스에 저장하는 작업을 주기적으로 수행하는 역할
#### 트라이 캐시
* 분산 캐시 시스템으로 주기적으로 트라이 데이터베이스에서 스냅샷을 떠서 읽기 연산 성능을 개선함
#### 트라이 데이터베이스
* 문서 저장소: 통째로 트라이를 저장함. MongoDB같은 NoSQL이 유용함
* 키-값 저장소: 접두어를 키로 하여 트라이 구조를 저장할 수 있음
### 질의 서비스
* 트라이 캐시로부터 조회하는 서버를 구성함
#### 성능 개선하기
##### 클라이언트
* 브라우저 캐싱
##### 서버
* 로그 데이터 수집시 샘플링 하기 (N개 데이터 중 1개씩만 수집하는 것)

### 트라이 연산
#### 트라이 생성
* 취합된 데이터로 트라이 생성
#### 트라이 갱신 방법
* 매주 한 번씩 새로운 트라이를 생성하여 대체하는 것
* 트라이 각 개별 노드들을 갱신하기 (이 방식은 모든 상위 노드 데이터도 갱신해야 해서 성능이 좋지 않음)
#### 검색어 삭제
* 조회하는 부분에 필터 계층을 두어서 부적절한 단어가 조회되지 않도록 함
* 해당 검색어를 삭제하는 것은 다음 갱신 시점에 적용하도록 함
* 그런데 k개의 검색어를 반환해야하는데 하나가 필터링되면 또 다시 조회를 수행해야 하는 비효율이 발생하는 건가?

### 저장소 규모 확장
* 첫글자 기준 샤딩 등을 도입해볼만 함
* 첫글자 이상의 글자수로 더 세분화해서 샤딩할 경우 신경써야할 점이 많아진다.

## 마무리
### 다국어화 지원의 경우
* 일단 유니코드로 저장해야 함
### 국가별 순위가 다른 경우
* 국가별로 다른 트라이와 cdn 사용
### 실시간 검색 기능을 제공해야 한다면?
* 현재 방식은 실시간 검색에 용이하지 않음
* 실시간 통계를 따로 구성하는게 맞을 듯
* 샤딩으로 작업 대상 데이터 양을 줄인다.
* 순위 모델을 바꿔서 최근 검색어에 대한 가중치를 높인다.
* 데이터가 스트림 형태로 들어올 수 있기 때문에 이에 맞는 아키텍처가 필요함
  * 이 책에서 제시한 것 중에 하둡은 실시간 처리에 적합하지 않은데 왜 있는지 모르겠음

# 14장 유튜브 설계
## 문제 이해 및 설계 범위 확정
* 일간 능동 사용자 5,000,000
* 한 사용자는 하루에 평균 5개의 비디오를 시청
* 10% 사용자가 하루에 1비디오 업로드
* 비디오 평균 크기는 300MB
* 비디오 저장을 위해 매일 새로 요구되는 저장 용량 = 5백만 * 10% * 300MB = 150TB
* CDN 비용
  * 클라우드 CDN은 나가는 데이터 양에 따라 과금됨
  * aws cloudfront는 미국 리전에서 1GB당 0.02 달러의 요금이 발생함
* 따라서 매일 발생하는 요금은 5,000,000 * 5 비디오 * 0.3GB * $0.02 = $150,000
## 개략적 설계안 제시 및 동의 구하기
### CDN과 OBS를 클라우드 상품을 이용하는 이유
* 시스템 설계가 모든 기술을 밑바닥부터 만드는 것이 아니기 때문
* 규모 확장이 큰 OBS나 CDN을 만드는 것은 매우 복잡하고, 비용이 많이 든다.
### 비디오 업로드 절차
* API 서버: 비디오 스트리밍을 제외한 다른 모든 요청을 처리
* 메타데이터 데이터베이스: 비디오의 메타데이터를 보관한다.
* 메타데이터 캐시: 성능을 높이기 위해 메타데이터와 사용자 객체를 캐시
* 원본 저장소: 원본 비디오를 보관할 대형 이진 파일 저장소 시스템
* 트랜스코딩 서버: 비디오 트랜스코딩은 비디오 인코딩이라 부르기도 하는 절차로, 비디오의 포맷을 변환하는 절차
* 트랜스코딩 비디오 저장소: 트랜스코딩이 완료된 비디오를 저장하는 저장소
* CDN: 비디오를 캐시하는 역할을 담당한다.
* 트랜스코딩 완료 큐: 비디오 트랜스코딩 완료 이벤트들을 보관할 메시지 큐다.
* 트랜스코딩 완료 핸들러: 트랜스코딩 완료 큐에서 이벤트 데이터를 꺼내어 메타데이터 캐시와 데이터베이스를 갱신할 작업 서버들이다.
##### 비디오 업로드 프로세스
1. 비디오를 원본 저장소에 업로드한다.
   * 이 책에는 비디오 업로드를 클라이언트가 바로 OBS에 업로드하는 형태로 나와있는데 이러면 보안적으로도 문제가 될 것이다.
   * pre-signed-url을 쓴다고 하더라도 API를 거쳐야 하지 않나?
2. 트랜스코딩 서버는 원본 저장소에서 해당 비디오를 가져와 인코딩
3. 트랜스코딩이 완료되면 저장소에 업로드하고, 이벤트를 큐에 발행함
4. 이벤트 핸들러가 이벤트를 핸들링하고, CDN에 비디오 복제
5. API 서버가 단말에 비디오 업로드가 완료되었음을 알린다.
   * 이건 webhook 작업인데 이걸 API가 수행하게 할 필요없을 것으로 보임
##### 메타데이터 갱신
* 사용자가 메타데이터 갱신 요청을 보낼 경우 이를 API에서 처리함

#### 비디오 스트리밍 절차
* 비디오 데이터는 인코딩 과정에서 스트리밍 데이터로 변환됨
* CDN을 통해 스트리밍됨

## 상세 설계
### 비디오 트랜스코딩
* 가공되지 않은 원본 데이터는 저장 공간을 많이 차지함
* 호환성 문제를 해결하기 위해 여러 포맷으로 비디오를 인코딩할 필요가 있음
* 끊김 없는 고화질 비디오 재생을 보장하려면,
  * 네트워크 대역폭이 충분하지 않은 사용자에게는 저화질 비디오를,
  * 대역폭이 충분한 사용자에게는 고화질 비디오를 보내야 바람직함
* 모바일은 네트워크 상황이 수시로 달라질 수 있기 때문에 비디오 화질을 자동으로 변경하거나 수동으로 변경할 수 있어야 함
#### 인코딩 포맷
* 컨테이너: 비디오 파일, 오디오, 메타데이터를 담는 바구니 같은 것. 컨테이너 포맷은 avi, mp4 같은 일반적인 확장자
* 코덱: 비디오 화질은 보존하면서 파일 크기를 줄일 목적으로 고안된 압축 및 압축 해제 알고리즘.
  * 가장 많이 사용되는 비디오 코덱은 H.254, VP9, HEVC
### 유향 비순환 그래프(DAG) 모델
* 각기 다른 유형의 비디오 프로세싱 파이프라인을 지원하는 한편 처리 과정의 병렬성을 높이기 위해 적절한 추상화된 작업 도구를 제공하는 것
### 비디오 트랜스코딩 아키텍처
#### 전처리기
* 비디오 분할: 비디오 스트림을 GOP 단위로 쪼개기
* DAG 생성: 클라이언트 프로그래머가 작성한 설정 파일에 따라 DAG 파이프라인을 생성
* 데이터 캐시: 전처리기는 분할된 비디오의 캐시이기도 함
#### DAG 스케줄러
* DAG 그래프를 몇 개 단계로 분할한 다음에 각각을 자원 관리자의 작업 큐에 집어넣는다.
#### 자원 관리자
* 자원 배분을 효과적으로 수행하는 역할을 담당함
* 큐와 스케줄러로 구성됨
* 작업 스케줄러는 큐에 있는 정보들을 컨슘해서 적절하게 작업 서버에 작업을 할당함
#### 작업 서버
* DAG에 정의된 작업을 수행함
#### 임시 저장소
* 작업을 위한 임시 저장소
* 작업이 완료되면 삭제됨
#### 인코딩 된 비디오
* 파이프라인 최종 결과물
### 시스템 최적화
#### 속도 최적화: 비디오 병렬 업로드
* 비디오 전부를 한 번의 업로드로 올리는 것은 비효율적이다.
* 이를 GOP로 나눠서 병렬적으로 업로드한다.
* 일부가 실패해도 빠르게 재개가 가능함
#### 속도 최적화: 업로드 센터를 사용자 근거리에 지정
* CDN을 분산하여 업로드 센터로도 활용
#### 속도 최적화: 모든 절차를 병렬화
* 메시지 큐를 도입하여 결합도를 낮추고 작업들은 각기 병렬적으로 처리할 수 있음
#### 안전성 최적화: 미리 사인된 업로드 URL
* 허가받은 사용자만이 올바른 장소에 비디오를 업로드할 수 있도록 하기 위해, 미리 사인된 업로드 URL을 사용함
1. 클라이언트는 HTTP 서버에 POST 요청을 하여 미리 사인된 URL을 받는다.
2. API 서버는 미리 사인된 URL을 돌려준다.
3. 클라이언트는 해당 URL이 가리키는 위치에 비디오를 업로드한다.
#### 안전성 최적화: 비디오 보호
* DRM 시스템 도입: 디지털 저작권 관리를 해주는 시스템
* AES 암호화: 비디오를 암호화하고 접근 권한을 설정하는 방식. 암호화된 비디오는 재생 시에만 복호화됨
* 워터마크: 비디오 위에 소유자 정보를 포함하는 이미지 오버레이를 올리는 것
### 비용 최적화
* CDN 비용이 비쌈
* 인기있는 비디오만 빈번히 재생된다는 long-tail 분포
  * 인기 있는 비디오는 CDN을 이용하고 나머지는 비디오 서버를 통해 재생하는 것
  * 인기가 별로 없는 비디오는 인코딩 할 필요가 없을 수 있음. 짧은 비디오라면 필요할 때만 인코딩해서 쓸 수도 있음
  * 지역에 따라 인기있는 비디오가 다를 수 있기 때문에 지역별로 CDN 구성을 다르게 할 필요가 있음
  * CDN 직접 구축
### 오류 처리
* 회복 가능 오류: retry 로직을 넣고 적절한 오류 코드 반환
* 회복 불가능 오류: 작업 중단하고 바로 적절한 오류 코드 반환
## 마무리
### API 계층 규모 확장성 확보 방안
* API 서버는 무상태 서버이므로 수평적 확장 가능
### 데이터베이스 계층의 규모 확장성 확보 방안
### 라이브 스트리밍
* 라이브 스트리밍의 경우 응답 지연이 좀 더 낮아야 함
* 라이브 스트리밍은 작은 단위의 데이터를 실시간으로 빨리 처리해야 되기 때문에 병렬화의 필요성이 떨어진다.
* 라이브 스트리밍은 오류 처리 방법을 달리해야 한다. 지연이 많은 방안은 사용할 수 없음
### 비디오 삭제
* 저작권을 위반한 비디오, 선정적 비디오, 불법적 비디오는 내려야 하고, 식별 방법을 구성해야 한다.