# 개략적 설계

## 데이터 수집 사이즈

- 검색이 진행될때 마다 해당 질의의 내용에 빈도수를 저장한다. twitter 를 검색하면 twitter에 대한 빈도수가 1로 저장되는것이다.

```sql
SELECT *
FROM FREQUENCY_TABLE
WHERE QUERY LIKE $prefix
ORDER BY FREQUENCY DESC
LIMIT 5
```

- 이 같은 쿼리로 가장 많이 사용된 검색어 top5를 구할 수있다.
- 해당 로직은 데이터 양이 적을 때는 나쁘지 않은 설계안이다. 하지만 데이터가 많아지면 데이터 베이스가 병목될 수 있고 정렬문제, Full Scan, QPS(Query Per Second)를 크게 증가시킬 위험이 있다.

# 상세 설계

## 트라이(trie) 자료구조

### 트라이 자료구조

- 트라이는 트리 형태의 자료구조다.
- 이 트리의 루트 노드는 빈 문자열을 나타낸다.
- 각 노드는 글자 하나를 저장하며, 26개의 자식 노드를 가질 수 있다.
- 각 트리 노드는 하나의 단어, 또는 접두어 문자열을 나타낸다.

![](https://github.com/sangminlee98/system-design-interview/assets/83197138/9fc336d7-36dd-4612-afe1-7d9213f3aee0)

- 가장 많이 사용된 질의어 k개는 다음과 같이 찾을 수 있다.
    - 해당 접두어를 표현하는 노드를 찾는다. 시간 복잡도는 O(p) 이다.
    - 해당 노드부터 시작하는 하위트리를 탐색하여 모든 유효 노드를 찾는다. 유효한 검색 문자열을 구성하는 노드가 유효 노드다. 시간 복잡도는 O(c) 이다.
    - 유효 노드들을 정렬하여 가장 인기 있는 검색어 k개를 찾는다. 시간 복잡도는 O(clogc) 이다.

- k=2 이고 검색창에 be를 검색했을때 알고리즘 동작 흐름

![](https://github.com/sangminlee98/system-design-interview/assets/83197138/5d5b4f50-6b2d-4842-bab0-ea5f8466e29f)

1. 접두어 노드 ‘be’ 를 찾는다.
2. 해당 노드부터 싲가하는 하위 트리를 탐색하여 모든 유효 노드를 찾는다.
3. 유효 노드를 정렬하여 2개만 골라낸다. [best: 35], [bet: 29]접두어 tr에 대해 검색된 2개의 인기 검색어이다.
- 이 알고리즘의 시간 복잡도는 위의 각 단계에 소요된 시간의 합이다. 즉 O(p) + O(c) + O(clogc)
- 이 알고리즘은 직관적이지만 최악의 경우에는 k개 결과를 얻으려고 전체 트라이를 다 검색해야 하는 일이 생길 수 있다. 이 문제를 해결할 방법으로는 다음의 두 가지가 있다.
1. 접두어의 최대 길이를 제한
2. 각 노드에 인기 검색어를 캐시

### 접두어 최대 길이 제한

- 사용자가 검색창에 긴 검색어를 입력하는 일은 거의 없다. 따라서 p값은 작은 정숫값이라고 가정해도 안전하다. 검색어의 최대 길이를 제한할 수 있다면 “접두어 노드를 찾는” 단계의 시간 복잡도는 O(p) 에서 O(작은 상숫값)=O(1) 로 바뀔 것이다.

### 노드에 인기 검색어 캐시

![](https://github.com/sangminlee98/system-design-interview/assets/83197138/a4349c00-1359-418f-ab19-16cb12b8db0e)
각 노드에 인기 질의어를 캐시하면 top5 검색어를 질의하는 시간 복잡도를 엄청나게 낮출 수 있다. 하지만 각 노드에 질의어를 저장할 공간이 많이 필요하게 된다는 단점이 있다. 그러나 빠른 응답속도가 아주 중요할 때는 이 정도 저장공간을 희생할 만한 가치는 있다.

1. 접수어 노드를 찾는 시간 복잡도는 O(1)로 바뀐다.
2. 최고 인기 검색어 5개를 찾는 질의의 시간 복잡도도 O(1)로 바뀐다. 검색 결과가 이미 캐시되어 있어서다.

## 데이터 수집 서비스

- 지금까지 살펴본 설계안은 사용자가 검색창에 뭔가 타이핑을 할 때마다 실시간으로 데이터를 수정했는데 이러한 방식은 실용적이지 못하다.
    - 매일 수천만 건의 질의가 입력될 텐데 그때마다 트라이를 갱신하면 질의 서비스는 심각하게 느려질 것이다.
    - 일단 트라이가 만들어지고 나면 인기 검색어는 그다지 자주 바뀌지 않을 것이다. 그러니 트라이는 그렇게 자주 갱신할 필요가 없다.

![](https://github.com/sangminlee98/system-design-interview/assets/83197138/e613c44e-ff25-4285-b1c2-c19f3d77288d)

### 데이터 분석 서비스 로그

- 검색창에 입력된 질의에 관한 원본 데이터가 보관된다. 수정은 이루어지지않으며 새로운 데이터만 추가된다.

### 로그 취합 서버

- 데이터 분석 서비스로부터 나오는 로그는 데이터도 방대하고 형식도 제각각이다. 따라서 이 데이터를 잘 취합하여 우리 시스템이 쉽게 소비할 수 있도록 해야한다.
- 실시간이 중요하면 데이터 취합 주기를 짧게 가져갈 필요가 있고 대부분의 경우에는 일주일에 한 번 정도로 로그를 취합해도 충분하다.

### 취합된 데이터

![](https://github.com/sangminlee98/system-design-interview/assets/83197138/b9a7315e-e9e6-462c-84d7-586da9982e43)

- time은 해당 주가 시작한 날짜, frequency 필드는 해당 중 사용된 횟수의 합이다.

### 작업 서버

- 작업 서버는 주기적으로 비동기적 작업을 실행하는 서버 집합이다. 트라이 자료구조를 만들고 트라이 데이터베이스에 저장하는 역할을 담당한다.

### 트라이 캐시

- 트라이 캐시는 분산 캐시 시스템으로 트라이 데이터를 메모리에 유지하여 읽기 연산 성능을 높이는 구실을 한다. 매주 트라이 데이터베이스의 스냅샷을 떠서 갱신한다.

### 트라이 데이터베이스

- 트라이 데이터베이스는 지속성 저장소다. 트라이 데이터베이스로 사용할 수 있는 선택지로는 다음의 2가지가 있다.
    1. 문서 저장소 : 새 트라이를 매주 만들 것으므로, 주기적으로 트라이를 직렬화하여 DB에 저장할 수 있다. 몽고디비 같은 문서 저장소를 활용하면 이런 데이터를 편리하게 저장할 수 있다.
    2. 키-값 저장소 : 트라이는 아래 로직을 적용하면 해시 테이블 형태로 변환 가능하다.
        - 트라이에 보관된 모든 접두어를 해시 테이블 키로 변환
        - 각 트라이 노드에 보관된 모든 데이터를 해시 테이블 값으로 변환

## 질의 서비스

![](https://github.com/sangminlee98/system-design-interview/assets/83197138/fe954ee6-7139-4f0e-92ad-6337e4afb121)

1. 검색 질의가 로드밸런서로 전송된다.
2. 로드밸런서는 해당 질의를 API 서버로 보낸다.
3. API 서버는 트라이 캐시에서 데이터를 가져와 해당 요청에 대한 자동완성 검색어 제안 응답을 구성한다.
4. 데이터가 트라이 캐시에 없는 경우에는 데이터를 DB에서 가져와 캐시에 채운다. 그래야 다음에 같은 접두어에 대한 질의가 오면 캐시에 보관된 데이터를 사용해 처리할 수 있다. 캐시 미스는 캐시 서버의 메모리가 부족하거나 캐시 서버에 장애가 있어도 발생할 수 있다.

최적화 방안

- AJAX 요청
- 브라우저 캐싱
- 데이터 샘플링 : N개 요청 가운데 1개만 로깅하도록 한다.

## 트라이 연산

### 트라이 생성

- 트라이 생성은 작업 서버가 담당하며, 데이터 분석 서비스의 로그나 DB로부터 취합된 데이터를 이용한다.

### 트라이 갱신

- 트라이를 갱신하는 방법은 2개가 있다.
    1. 매주 한 번 갱신하는 방법. 새로운 트라이를 만든 다음에 기존 트라이를 대체한다.
    2. 트라이의 각 노드를 개별적으로 갱신하는 방법. 본 설계안에선 채택안했는데 성능이 좋지 않아서다. 하지만 트라이가 작을 때는 고려해봄직한 방안이다.

### 검색어 삭제

- 혐오성이 짙거나, 폭력적이거나 여러 가지로 위험한 질의어를 자동완성 결과에서 제거해야 한다. 이를 위한 좋은 방법은 API 서버와 트라이 캐시 앞에 필터 계층 을 두고 부적절한 질의어가 반환되지 않도록 하는 것이다. 필터 계층을 두면 필터 규칙에 따라 검색 결과를 자유롭게 변경할 수 있다는 장점이 있다. DB에서 해당 검색어를 물리적으로 삭제하는 것은 다음번 업데이트 사이클에 비동기적으로 진행하면 된다.

### 저장소 규모 확장

- 본 요구사항은 영어만 지원하면 되기 때문에 첫 글자를 기준으로 샤딩 하는 방법을 생각해 볼 수 있다.
    - 검색어를 보관하기 위해 두 대 서버가 필요하다면 ‘a’부터 ‘m’까지 글자로 시작하는 검색어는 첫 번재 서버에 저장하고 나머지는 두 번째 서버에 저장 한다.
    - 세 대 서버가 필요하다면 ‘a’ ~ ‘i’ 까지 첫번째 서버, ‘j’~’r’ 까지는 두번째 서버, 나머지는 세 번째 서버에 저장한다.
- 이 방법을 쓰는 경우 사용 가능한 서버는 최대 26대로 제한되는데, 영어 알파뱃은 26자 밖에 없기 때문이다. 이 이상으로 서버를 늘릴려면 계층적으로 해야한다.
- 위의 방법은 데이터를 각 서버에 균등하게 배분하기는 불가능하다. 본 설계안에선 과거 질의 데이터의 패턴을 분석하여 샤딩하는 방법을 제안한다. 이 그림에서 검색어 대응 샤드 관리자는 어떤 검색어가 어느 저장소 서버에 저장되는지에 대한 정보를 관리한다.

# 마무리

- 다국어 지원 : 비영어권 국가에서 사용하는 언어를 지원하려면 트라이에 유니코드 데이터를 저장해야한다.
- 국가별로 인기 순위 : 국가별로 다른 트라이를 사용하면 된다. 트라이를 CDN에 저장하여 응답속도를 높이는 방법도 생각해볼 수 있다.
- 실시간 검색어 반영 : 현재 설계안은 그런 검색어를 지원하기에 적합하지 않다. 이유는 다음과 같다.
    - 작업 서버가 매주 한 번씩만 돌도록 되어 있어서 시의 적절하게 트라이를 갱신할 수 없다.
    - 설사 때맞춰 서버가 실행된다 해도, 트라이를 구성하는 데 너무 많은 시간이 소요된다.

------------------

# 14장 유튜브 설계

# 개략적 설계안 제시 및 동의 구하기

- 시스템 면접 설계는 모든 것을 밑바닥부터 만드는 것과 상관없다. 어떻게 구현할지 상세한 설계를 제시하는것은 지나치고 주어진 시간안에 적절한 기술을 골라 설계를 마치는것이 중요하다.
- 개략적으로 보면 이 시스템은 다음의 세 개 컴포넌트로 구성된다.

- 단말: 컴퓨터, 모바일, 스마트TV 등을 통해 유튜브를 시청할 수 있다.
- CDN: 비디오는 CDN에 저장된다. 재생 버튼을 누르면 CDN으로부터 스트리밍이 이루어진다.
- API서버: 비디오 스트리밍을 제외한 모든 요청은 API서버가 처리한다.

## 비디오 업로드 절차

![](https://velog.velcdn.com/images/nnagman/post/350d70ec-c999-4085-a7e0-6bcf1ac957e1/image.png)

- 사용자 : 컴퓨터나 모바일을 이용해 유튜브를 시청하는 이용자다.
- 로드밸런서 : API 서버 각각으로 고르게 요청을 분산하는 역할을 담당한다.
- API서버 : 비디오 스트리밍을 제외한 모든 요청을 처리한다.
- 메타데이터 DB : 비디오의 메타데이터를 보관한다. 샤딩과 다중화를 적용하여 성능 및 가용성 요구사항을 충족한다.
- 메타데이터 캐시 : 성능을 높이기 위해 비디오 메타데이터와 사용자 객체는 캐시한다.
- 원본 저장소 : 원본 비디오를 보관할 대형 이진 파일 저장소 시스템이다.
- 트랜스코딩 서버 : 비디오 트랜스코딩은 비디오 인코딩이라 부르기도 하는 절차로, 비디오의 포맷을 변환하는 절차다. 단말이나 대역폭 요구사항에 맞는 최적의 비디오 스트림을 제공하기 위해 필요하다.
- 트랜스코딩 비디오 저장소 : 트랜스코딩이 완료된 비디오를 저장하는 BLOB 저장소이다.
- CDN : 비디오를 캐시하는 역할을 담당한다. 사용자가 재생 버튼을 누르면 비디오 스트리밍은 CDN을 통해 이루어진다.
- 트랜스코딩 완료 큐 : 비디오 트랜스코딩 완료 이벤트들을 보관할 메시지 큐다.
- 트랜스코딩 완료 핸들러 : 트랜스코딩 완료 큐에서 이벤트 데이터를 꺼내어 메타데이터 캐시와 DB를 갱신할 작업 서버들이다.

### 흐름 설명

- 비디오 업로드
  1. 비디오를 원본 저장소에 업로드한다.
  2. 트랜스코딩 서버는 원본 저장소에서 해당 비디오를 가져와 트랜스코딩을 시작한다.
  3. 트랜스코딩이 완료되면 아래 두 절차가 병렬적으로 수행된다.
    1. 3a 완료된 비디오를 트랜스코딩 비디오 저장소로 업로드한다.
    2. 3b 트랜스코딩 완료 이벤트를 트랜스코딩 완료 큐에 넣는다.
    3. 3b.1.a, 3b.1.b. 완료 핸들러가 메타데이터 DB와 캐시를 갱신한다.
  4. API 서버가 단말에게 비디오 업로드가 끝나서 스트리밍 준비가 되었음을 알린다.

- 메타데이터 갱신
  - 원본 저장소에 파일이 업로드되는 동안 단말은 병렬적으로 비디오 메타데이터 갱신 요청을 API 서버에 보낸다. 이 요청에 포함된 메타데이터에는 파일 이름, 크기, 포맷등의 정보가 들어있다.


### 비디오 스트리밍 절차

- 유튜브에서 비디오 재생버튼을 누르면 스트리밍은 바로 시작되며, 비디오 다운로드가 완료되어야 영상을 볼 수 있다거나 하는 불편함은 없다. 여기서 다운로드라 함은 비디오를 단말로 내려 받는 거을 말한다. 비디오 스트리밍이 이루어지는 절차를 논하기에 앞서 우리는 먼저 스트리밍 프로토콜 이라는 개념을 알아두어야 한다. 스트리밍 프로토콜은 비디오 스트리밍을 위해 데이터를 전송할 떄 쓰이는 표준화된 통신방법이다.
  - 스트리밍 프로토콜 종류
    - MPEG-DASH (Moving Picture Experts Group), (Dynamic Adaptive Streaming over HTTP)
    - 애플 HLS (HTTP Live Streaming)
    - 마이크로소프트 스무드 스트리밍 (Microsoft Smooth Streaming)
    - 어도비 HTTP 동적 스트리밍 (Adobe HTTP Dynamic Streaming, HDS)

# 상세 설계

### 비디오 트랜스코딩

- 비디오를 녹화하면 단말은 해당 비디오를 특정 포맷으로 저장한다. 이 비디오가 다른 단말에서도 재생되려면 다른 단말과 호환되는 비트레이트(비디오를 구성하는 비트가 얼마나 빨리 처리되어야하는지를 나타내는 단위)와 포맷으로 저장되어야 한다.
  - 중요한 이유
    - 가공되지 않은 원본 비디오는 저장 공간을 많이 차지한다.
    - 상당수의 단말과 브라우저는 특정 종류의 비디오 포맷만 지원한다.
    - 사용자에게 끊김 없는 고화질 비디오 재생을 보장하려면, 네트워크 대역폭이 떨어지는 사용자에게는 저화질 비디오를, 충분한 사용자에겐 고화질 비디오를 보내는 것이 바람직하다.
    - 모바일 단말의 경우 네트워크 상황이 수시로 달라진다. 비디오 화질을 자동으로 변경하거나 수동으로 변경할 수 있도록 하는 것이 바람직하다.
  - 인코딩 포맷
    - 컨테이너 : 비디오 파일, 오디오, 메타데이터를 담는 바구니 같은것, 컨테이너 포맷은 .avi, .mov, .mp4 같은 파일 확장자를 보면 알 수 있다.
    - 코덱 : 비디오 화질은 보존하면서 파일 크기를 줄일 목적으로 고안된 압축 및 압축 해제 알고리즘이다. H.264, VP9, HEVC 가 있다.

### 유향 비순환 그래프 모델

![](https://velog.velcdn.com/images/nnagman/post/608bf92a-1467-42e2-a7e7-417363044ddf/image.png)

- 비디오를 트랜스코딩하는 것은 컴퓨팅 자원을 많이 소모할 뿐 아니라 시간도 많이 드는 작업이다. 게다가 콘텐츠 창작자는 각자 자기만의 비디오 프로세싱 요구사항을 갖고 있다. 이처럼 각기 다른 유형의 비디오 프로세싱 파이프라인을 지원하는 한편 처리 과정의 병렬성을 높이기 위해서는 적절한 수준의 추상화를 도입하여 클라이언트 프로그래머로 하여금 실행할 작업을 손수 정의할 수 있도록 해야한다.

### 비디오 트랜스코딩 아키텍쳐

![](https://velog.velcdn.com/images/nnagman/post/66b2faa9-8d20-4fd9-ad68-5f648bc0120a/image.png)

- 전처리기
  - 비디오 분할 : 비디오 스트림을 GOP로 불리는 단위로 쪼갠다. GOP는 특정 순서로 배열된 프레임이며 길이는 몇 초 정도이다. 지원하지 않는 단말이나 브라우저가 있기에 그런 경우는 전처리기가 비디오 분할을 대신한다.
  - DAG 생성 : 클라이언트 프로그래머가 작성한 설정 파일에 따라 DAG를 만들어낸다.
  - 데이터 캐시 : 전처리기는 분할된 비디오의 캐시이기도 하다. 안정성을 높이기 위해 GOP와 메타데이터를 임시 저장소에 보관한다. 비디오 인코딩에 실패하면 보관된 데이터를 활용해 인코딩을 재개한다.
- DAG 스케줄러
  - DAG 스케줄러는 DAG 그래프를 몇 개 단계로 분할한 다음에 그 각각을 자원 관리자의 작업 큐에 집어넣는다.
  - 하나의 DAG그래프를 2개 작업 단계로 쪼갰을때, 첫 단계에서는 비디오, 오디오, 메타데이터를 분리한다. 두번째 단계에서는 비디오 파일을 인코딩하고 섬네일을 추출하며, 오디오 파일도 인코딩한다.
- 자원 관리자
  - 자원 배분을 효과적으로 수행하는 역할을 담당한다. 세 개의 큐와 작업 스케쥴러로 구성된다.
    - 작업 큐 : 실행 할 작업이 보관되어 있는 우선순위 큐
    - 작업 서버 큐 : 작업 서버의 가용 상태 정보가 보관되어 있는 우선순위 큐
    - 실행 큐 : 현재 실행 중인 작업 및 작업 서버 정보가 보관되어 있는 큐
    - 작업 스케쥴러 : 최적의 작업/서버 조합을 골라, 해당 작업 서버가 작업을 수행하도록 지시하는 역할
  - 작업 관리자 동작
    - 작업 관리자는 작업 큐에서 가장 높은 우선순위의 작업을 꺼냄
    - 작업 관리자는 해당 작업을 실행하기 적합한 작업 서버를 고름
    - 작업 스케쥴러는 해당 작업 서버에게 작업 실행을 지시
    - 작업 스케쥴러는 해당 작업이 어떤 서버에게 할당되었는지에 관한 정보를 실행 큐에 넣음
    - 작업 스케쥴러는 작업이 완료되면 해당 작업을 실행 큐에서 제거
- 작업 서버
  - 작업 서버는 DAG에 정의된 작업을 수행
- 임시 저장소
  - 임시 저장소 구현에는 여러 저장소 시스템을 활용할 수 있다. 어떤 시스템을 선택할 것이냐에 따라 정보가 달라진다. 예를 들어 메타데이터는 빈번히 참조하는 정보 + 크기도 작기에 메모리에 캐시해 두는 것이 좋다. 그러나 비디오/오디오 데이터는 BLOB 저장소에 두는 것이 바람직하다.
- 인코딩된 비디오
  - 인코딩 파이프라인의 최종 결과물

## 시스템 최적화

### 속도 최적화: 비디오 병렬 업로드

- 비디오 전부를 한 번의 업로드로 올리는 것은 비효율적이다. 하나의 비디오는 작은 GOP로 분할할 수 있다. 이렇게 분할한 GOP를 병렬적으로 업로드하면 설사 일부가 실패해도 빠르게 업로들ㄹ 재개할 수 있다.

### 속도 최적화: 업로드 센터를 사용자 근거리에 지정

- 업로드 속도를 개선하는 또 다른 방법은 업로드 센터를 여러 곳에 두는 것이다. 이를 위해서 본 설계안은 CDN을 업로드 센터로 이용한다.

### 속도 최적화: 모든 절차를 병렬화

- 낮은 응답지연을 달성하는 것은 어렵다. 이를 위해 시도해 볼 수 있는 하나의 방법은 느슨하게 결합된 시스템을 만들어서 병렬성을 높이는 것이다.
- 메시지 큐를 도입하기 전에 인코딩 모듈은 다운로드 모듈의 작업이 끝나기를 기다려야 했다.
- 메시지 큐를 도입한 뒤에 인코딩 모듈은 다운로드 모듈의 작업이 끝나기를 더 이상 기다릴 필요가 없다. 메시지 큐에 보관된 이벤트 각각을 인코딩 모듈은 병렬적으로 처리할 수 있다.

### 안전성 최적화: 미리 사인된 업로드 URL

- 허가받은 사용자만이 올바른 장소에 비디오를 업로드할 수 있도록 하기 위해 미리 사인된 업로드 URL을 이용한다.  다음과 같은 절차가 있다.
  1. 클라이언트는 HTTP 서버에 POST 요청을 하여 미리 사인된 URL을 받는다. 해당 URL이 가리키는 객체에 대한 접근 권한이 이미 주어져 있는 상태다.
  2. API 서버는 미리 사인된 URL을 돌려준다.
  3. 클라이언트는 해당 URL이 가리키는 위치에 비디오를 업로드한다.

### 안전성 최적화: 비디오 보호

- 비디오 원본을 도난 당할까 우려해서 많은 콘텐츠 제작자가 비디오를 인터넷에 업로드하길 주저한다. 다음과 같은 방법으로 비디오의 저작권을 보고할수 있다.
  - 디지털 저작권 관리 시스템 도입 : 이 부문에서 가장 널리 사용되는 시스템으로는 애플의 페어플레이, 구글의 와이드바인, 마이크로스프트의 플레이레디가 있다.
  - AES 암호화 : 비디오를 암호화하고 접근 권한을 설정하는 방식이다. 암호화된 비디오는 재생 시에만 복호화한다.
  - 워터마크 : 비디오 위에 소유자 정보를 포함하는 이미지 오버레이를 올리는 것이다. 회사 로고나 이름 등을 이 용도에 사용할 수 있다.

### 비용 최적화

- CDN은 해당 시스템의 핵심 부분이다. 하지만 개략적인 추정치에서도 알 수 있듯 CDN은 비싸다. 데이터 크기가 크면 클수록 더하다. 연구 결과에 따르면 비디오 스트리밍은 롱테일 분포를 따른다. 인기 있는 비디오는 빈번히 재생되는 반면, 나머지는 거의 보는 사람이 없다.
  1. 인기 비디오는 CDN을 통해 재생하되 다른 비디오는 비디오 서버를 통해 재생한다.
  2. 인기가 별로 없는 비디오는 인코딩 할 필요가 없을 수도 있다. 짧은 비디오라면 필요할 때 인코딩하여 재생한다.
  3. 어떤 비디오는 특정 지역에서만 인기가 높다. 이런 비디오는 다른 지역에 옮길 필요가 없다.
  4. CDN을 직접 구축하고 인터넷 서비스 제공자와 제휴한다. CDN을 직접 구축하는 것은 초대형 프로젝트다.

## 오류 처리

- 시스템 오류는 대형 시스템에서는 불가피하다. 장애를 잘 감내하는 시스템을 만들려면 이런 오류를 우아하게 처리하고 빠르게 회복해야 한다. 시스템 오류에는 2가지 종류가 있다.
  - 회복 가능 오류 : 특정 비디오 세그먼트를 트랜스코딩하다 실패했다거나 하는 오류는 회복 가능한 오류에 속한다. 일반적으로 보자면 이런 오류는 몇 번 재시도 하면 해결된다. 하지만 계속해서 실패하고 복구가 어렵다 판단되면 클라이언트에게 적절한 오류 코드를 반환해야 한다.
  - 회복 불가능 오류 : 비디오 포맷이 잘못되었다거나 하는 회복 불가능한 오류가 발견되면 해당 비디오에 대한 작업을 중단하고 클라이언트에게 적절한 오류 코드를 반환해야 한다.
- 시스템 컴포넌트 각각에 발생할 수 있는 오류에 대한 전형적 해결 방법
  - 업로드 오류 : 재시도
  - 비디오 분할 오류 : 전체 비디오를 서버로 전송하고 서버가 해당 비디오 분할을 처리하도록 한다.
  - 트랜스코딩 오류 : 재시도
  - 전처리 오류 : DAG 그래프를 재생성
  - DAG 스케줄러 오류 : 작업을 다시 스케쥴링
  - 자원 관리자 큐에 장애 발생 : 사본을 이용
  - 작업 서버 장애 : 다른 서버에서 해당 작업을 재시도
  - API 서버 장애 : API 서버는 무상태이므로 신규 요청은 다른 API 서버로 우회
  - 메타데이터 캐시 서버 장애 : 데이터는 다중화되어 있으므로 다른 노드에서 데이터를 여전히 가져올 수 있다.
  - 메타데이터 DB 서버 장애 : 주 서버가 죽었다면 부 서버 가운데 하나를 주 서버로 교체, 부 서버가 죽었다면 다른 부 서버를 통해 읽기 연산을 처리하고 죽은 서버는 새것으로 교체