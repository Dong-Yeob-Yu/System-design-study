# 5장. 안정 해시 설계

수평적 규모 확장성 달성을 위해서는 요청 또는 데이터를 서버에 균등하게 분배하는 것이 중요한데, 이를 위해 보편적으로 안정 해시라는 기술을 사용한다.

## 해시 키 재배치(rehash) 문제

N개의 캐시 서버들에 부하를 균등하게 분배하는 보편적인 방법은 아래의 해시 함수를 사용하는 것이다.

`serverIndex = hash(key) % N`

이 방법은 대부분의 경우 잘 작동하지만 **서버 풀(server pool)의 크기가 변경되거나, 데이터 분포가 균등하지 않는 경우**에는 문제가 발생한다. 특히 서버가 추가/제거된다면 서버 인덱스 값들이 달라져 대량의 캐시 미스가 발생하는데, 이를 안정 해시로 해결할 수 있다.

## 안정 해시

**안정 해시**(consistent hash)는 해시 테이블 크기가 고정될 때 **평균적으로 오직 k/n개의 키만 재배치**하는 해시 기술이다. (k = 키의 개수, n = 슬롯의 개수) 대부분의 전통적 해시 테이블에서는 이와 달리 슬롯의 수가 바뀌면 거의 대부분의 키를 재배치한다.

### 안정 해시의 이점

서버가 추가/삭제될 때 재배치되는 키의 수를 최소화한다.

데이터를 보다 균등하게 분포시킬 수 있다. → 수평적 규모 확장성을 달성하기 쉽다.

특정 샤드에 대한 접근이 지나치게 자주 발생하는 핫스팟(hotspot) 키 문제를 줄인다.

### 안정 해시의 기본 구현법

해시 함수 f로 SHA-1을 사용하고, 이 함수의 출력값 범위는 x0, x1, .., xn이라고 하자.

SHA-1의 **해시 공간**(hash space) 범위는 0부터 $2^{160}$ - 1이므로 x0은 0, xn은 $2^{160}$ - 1이며, 나머지는 그 사이의 값을 갖게 된다.

![image](https://github.com/user-attachments/assets/7474e309-e05d-4744-9626-41045d856d52)

해시 공간의 양쪽을 구부려 접으면 **해시 링**(hash ring)이 만들어진다.

<img src="https://github.com/user-attachments/assets/f405a875-8ef0-48ce-9c2e-81eaa46ff159" width="440" height="450"/>

안정 해시 알고리즘은 MIT에서 처음 제안되었는데, 기본 절차는 다음과 같다.

- 서버와 키를 **균등 분포**(uniform distribution) 해시 함수를 사용해 해시 링에 배치한다. 여기에서 사용되는 해시 함수는 “해시 키 재배치 문제”의 함수와 다르며, 나머지 연산 %을 사용하지 않는다.
  
- 키는 해당 키의 위치로부터 시계 방향으로 링을 탐색할 때 첫 번째로 만나는 서버에 저장된다.

![image](https://github.com/user-attachments/assets/b796299e-9abd-4f70-b393-3c078de0e884)

서버가 추가 또는 제거되더라도 **키의 일부만 재배치**하면 되므로 나머지 키에는 영향을 주지 않는다. 이때 *재배치된 노드와 그로부터 반시계 방향에 있는 첫 번째 서버 사이*의 키만이 재배치된다.

### 기본 구현법의 두 가지 문제

안정 해시 알고리즘의 기본 구현법에는 두 가지 문제가 있다.

첫 번째 문제는 서버가 추가/제거되는 상황을 감안하면 **파티션(partition)의 크기를 균등하게 유지하는 게 불가능**하다는 것이다. 파티션이란 인접한 서버 사이의 해시 공간으로, 즉 각 서버들이 할당받는 해시 공간의 크기가 각각 달라지는 것이다.

두 번째 문제는 **키의 균등 분포를 달성하기가 어렵다**는 것이다.

이 문제들을 해결하기 위해 도입된 기법이 **가상 노드**이다.

### 가상 노드 (virtual node)

가상 노드는 실제 노드 또는 서버를 가리키는 노드로서, 하나의 서버는 링 위에 여러 개의 가상 노드를 가질 수 있다. 각 서버는 가상 노드에 의해 생기는 여러 개의 파티션을 관리해야 한다.

![image](https://github.com/user-attachments/assets/870f2187-282c-4fca-9240-e1c9a3f7f396)

키가 저장되는 서버를 결정하는 방법은 동일한데, 키가 처음으로 만나는 노드가 가상 노드라면 그 노드가 가리키는 실제 서버에 키가 저장된다.

**가상 노드가 많아질수록 키의 분포가 더 균등**해지지만, 가상 노드 데이터를 저장하기 위해 더 많은 공간이 요구된다. 시스템 요구사항에 맞게 tradeoff가 발생하는 것이다.
