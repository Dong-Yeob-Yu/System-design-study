# 5장 안정 해시 설계
## 해시 키 재배치 문제
* N개의 서버가 있다고 할때 부하를 균등하게 나누는 보편적인 방법은 아래 해시 함수를 사용하는 것

> serverIndex = hash(key) % N (N은 서버의 개수)

* 위 방식이 잘 동작하기 위한 전제 조건
  * 서버 풀의 크기가 고정
    * 서버에 장애가 발생할 경우 대규모 캐시 미스가 발생하게 됨
  * 데이터 분포가 균등
    * 데이터 분포가 균등하지 않으면 부하 분산 효과가 약해짐
* 안정 해시는 분산 환경에서의 이러한 문제들을 효과적으로 해결하는 기술

## 안정 해시
* 안정 해시는 해시 테이블 크기가 조정될 때 평균적으로 오직 k/n개의 키만 재배치하는 해시 기술
  * k는 키의 개수
  * n은 슬롯의 개수
* 기본 해시 방식은 크기 조정시 대부분의 키를 재배치함 
### 해시 링
* 해시 링은 해시 공간의 양쪽을 구부려 접은 형태로 인식하는 논리적 개념
![해시링](https://miro.medium.com/v2/resize:fit:1400/format:webp/0*t4j62fOlDC5tpZex)

### 해시 서버와 해시 키 구조
* 해시 함수를 통해 서버 이름이나 키 값을 링 위의 어떤 위치에 대응시킬 수 있다.
* 어떤 키가 저장되는 서버는 해당 키의 위치로부터 시계 방향으로 링을 탐색해 나가면서 만나는 첫 번째 서버
![안정 해시 구조](https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5KbShTA_8xt-p1Dz)

### 서버 추가
* 서버를 추가하더라도 키 가운데 일부만 재배치
![서버 추가](https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Odc0qVAG1lqEwxjH)

### 서버 제거
* 서버를 제거하더라도 키 가운데 일부만 재배치
![서버 제거](https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jeTqN8cStCr-YwNJ)

### 기본 구현법의 두 가지 문제
1. 서버가 추가되거나 삭제되는 상황을 감안하면 파티션의 크기를 균등하게 유지하는 것이 불가능
2. 키의 균등 분포를 달성하기 어려움

> 이러한 문제를 해결하기 위해 제안 된 기법이 가상 노드(virtual node) 또는 복제(replica)

### 가상 노드
* 가상 노드는 실제 노드 또는 서버를 가리키는 노드
* 하나의 서버는 링 위에 여러 개의 가상 노드를 가질 수 있다.
![가상 노드](https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9tCRZopfnd4K83wY)

## 안정 해시의 이점
* 서버가 추가되거나 삭제될 때 재배치되는 키의 수가 최소화된다.
* 데이터가 보다 균등하게 분포되기 때문에 수평적 규모 확장성 달성하기 용이함.
* 핫스팟 키 문제를 줄인다.
  * 핫스팟 키 문제: 특정한 서버에 키가 몰리는 문제

# 6장 키-값 저장소 설계
* 키-값 저장소는 키-값 쌍으로 데이터를 저장하는 비 관계형 데이터베이스
* 성능상 키의 길이는 짧을수록 좋다.
## 설계를 위한 문제 이해 및 설계 범위 확정
* 키-값 쌍의 크기 10KB
* 큰 데이터를 저장할 수 있어야 함
* 높은 가용성 제공
  * 시스템 장애가 있더라도 빠르게 응답이 가능해야 함
* 높은 규모 확장성 제공
  * 트래픽 양에 따라 자동적으로 서버 증설/삭제가 이루어져야 함
* 데이터 일관성 수준 조정이 가능해야 함
* 응답 지연시간이 짧아야 함

## 단일 서버 키-값 저장소
* 키-값 쌍 전부를 메모리에 해시 테이블로 저장하기
* 빠른 속도를 보장하지만 메모리 공간의 한계가 있을 수 있음
  * 개선책1: 데이터 압축
  * 개선책2: 자주 쓰이는 데이터만 메모리에 두고 나머지는 디스크에 저장

## 분산 키-값 저장소
### CAP 정리
* 일관성(Consistency): 분산 시스템에 접속하는 모든 클라이언트는 어떤 노드에 접속했느냐에 관계없이 언제나 같은 데이터를 볼 수 있어야 함
* 가용성(Availability): 분산 시스템에 접속하는 클라이언트는 일부 노드에 장애가 발생하더라도 항상 응답을 받을 수 있어야 함
* 파티션 감내(Partition Tolerance): 네트워크 파티션이 발생하더라도 시스템이 계속 동작하여야 함
  * 네트워크 파티션: 두 노드 사이에 통신 장애가 발생한 것

> CAP 정리는 위 요소 중 어떤 두 가지를 충족하려면 나머지 하나는 반드시 희생되어야 한다는 것을 의미
![CAP](https://miro.medium.com/v2/resize:fit:946/format:webp/1*rxTP-_STj-QRDt1X9fdVlA.png)

### 실세계의 분산 시스템
* 분산 시스템에서는 파티션 문제를 피할 수 없다.
* 파티션이 발생한 서버는 최신 데이터가 동기화되지 않아서 오래된 사본을 갖는 상태가 된다.
* 파티션이 발생할 경우 일관성과 가용성 사이에서 하나를 선택해야 함
  * CP를 선택할 경우: 데이터 불일치를 회피하기 위해 다른 서버들은 쓰기 연산을 중단해야 하고, 이 경우 가용성이 깨짐
    * 은행권 시스템이 대부분 이 구조를 채택함
  * AP를 선택할 경우: 낡은 데이터를 반환할 위험이 있더라도 계속 읽기 연산을 허용해야 함. 다른 서버들은 계속 쓰기 연산을 허용할 것이고, 파티션이 해결된 뒤에 새 데이터를 문제있는 서버에 전달할 것
### 시스템 컴포넌트
#### 데이터 파티션
* 대규모 애플리케이션의 경우 전체 데이터를 한 대 서버에 욱여넣는 것은 불가능하다.
* 단순한 해결책은 데이터를 작은 파티션으로 분할한 다음 여러 서버에 저장하는 것
* 파티션 단위를 나눌 때 고려해야할 사항
  * 데이터를 여러 서버에 고르게 분산할 수 있는가?
  * 노드가 추가되거나 삭제될 때 데이터의 이동을 최소화할 수 있는가?
* 안정 해시는 이런 문제를 해결하는데 적합한 기술
* 안정 해시로 데이터를 파티션하면 좋은 점
  * 규모 확장 자동화(auto-scaling): 시스템 부하에 따라 서버가 자동으로 추가되거나 삭제되도록 만들 수 있다.
  * 다양성: 각 서버의 용량에 맞게 가상 노드 수를 조정할 수 있다.
#### 데이터 다중화
* 높은 가용성과 안정성을 확보하기 위해 데이터를 N개의 서버에 비동기적으로 다중화(replication)할 필요가 있다.
* N개의 서버를 선정하는 방법
  * 어떤 키를 해시 링 위에 배치한 후, 그 지점으로부터 시계 방향으로 링을 순회하면서 만나는 첫 N개의 서버에 데이터 사본을 보관하는 것
  * 가상 노드를 사용한다면 N개의 노드가 대응될 실제 물리 서버의 개수가 N보다 작아질 수 있기 때문에 같은 물리 서버를 중복으로 선택하지 않도록 해야 함
#### 데이터 일관성
* 여러 노드에 다중화된 데이터는 적절히 동기화 되어야 한다.
* 정족수 합의(Quorum Consensus) 프로토콜을 사용하면 읽기/쓰기 연산 모두에 일관성을 보장할 수 있다.
* 쓰기 연산에 대한 정족수, 읽기 연산에 대한 정족수를 정의하여 중재자가 정족수를 넘는 갯수의 성공 응답을 받아야 해당 연산이 성공한 것으로 판단하는 것
  * R = 1, W = N: 빠른 읽기 연산에 최적화된 시스템
  * W = 1, R = N: 빠른 쓰기 연산에 최적화된 시스템
  * W + R > N: 강한 일관성이 보장됨(보통 N = 3, W = R = 2)
  * W + R <= N: 강한 일관성이 보장되지 않음
  * (N: 사본 개수, W: 쓰기 연산에 대한 정족수, R: 읽기 연산에 대한 정족수)

![정족수 합의](https://www.durichitayat.net/static/11f731fd6d6fbfebb42e5951bd83cf39/3ceac/distributed-consensus.png)
#### 일관성 모델
* 강한 일관성: 모든 읽기 연산은 가장 최근에 갱신된 결과를 반환한다.
  * 모든 사본에 쓰기 연산 겨로가가 반영될 때까지 해당 데이터에 대한 읽기/쓰기를 금지하는 것
* 약한 일관성: 읽기 연산은 가장 최근에 갱신된 결과를 반환하지 못할 수 있다.
* 최종 일관성: 약한 일관성의 한 형태로, 갱신 결과가 결국에는 모든 사본에 동기화되는 모델
#### 비 일관성 해소 기법: 데이터 버저닝
* 버저닝(versioning)과 벡터 시계(vector clock)으로 일관성이 깨지는 문제를 해소하기
  * 버저닝: 데이터의 버전을 관리하여 낙관적 락을 거는 것
  * 벡터 시계: 분산 서버 간의 데이터 버저닝을 위한 데이터 구조
#### 장애 감지
* 모든 노드 사이에 멀티캐스팅 채널을 구축
  * 노드 갯수가 많아질수록 비효율적
* 가십 프로토콜: 멤버십 목록을 기반으로 박동 카운터(heartbeat counter)를 관리
  * 어떤 멤버의 박동 카운터 값이 지정된 시간 동안 갱신되지 않으면 장애로 판단

![가십 프로토콜](https://www.durichitayat.net/static/2fb35a6e01a3e44a51c4a5f5c6bacf02/387f2/heartbeat-membership-list.png)
#### 일시적 장애 처리
* 엄격한 종족수: 장애시 읽기와 쓰기 연산을 금지
* 느슨한 정족수: 임시로 다른 서버가 대신해서 요청을 처리하여 가용성을 높이는 것
* 단서 후 임시 위탁: 추후 복구를 대비해서 처리된 쓰기 연산에 대한 단서를 남기는 것 
#### 영구 장애 처리
* 반-엔트로피(anti-entropy) 프로토콜: 사본 간의 일관성이 망가진 상태를 탐지하고 전송 데이터의 양을 줄이기 위해 머클 트리 사용
* 머클 트리: 각 노드에 그 자식 노드들에 보관된 값의 해시, 또는 자식 노드들의 레이블로부터 계산된 해시값을 레이블로 붙여두는 트리
* 각 서버의 머클 트리 값을 비교해가면서 값이 다른 자식 노드의 데이터를 동기화함
![머클 트리](https://miro.medium.com/v2/resize:fit:1324/format:webp/0*zrmNIzTcyPjPjni_.png)
#### 데이터 센터 장애 처리
* 데이터 센터 다중화

### 시스템 아키텍처 다이어그램
#### 카산드라
![카산드라](https://media.geeksforgeeks.org/wp-content/uploads/20190912221345/Write-Operation.jpg)
* 블룸 필터: 집합 내에 특정 원소가 존재하는지를 확인하는 자료 구조
  * 공간과 시간의 효율성을 위해 일부 에러를 허용하는 해시 함수를 통해 원소의 존재 여부를 확인


## 그림 출처
https://medium.com/@akshayp344/load-balancing-part-2-consistent-hashing-a819b26768f4
https://ashvinchoudhary.medium.com/understanding-cap-theorem-real-world-examples-and-databases-d1ce0d807dca
https://www.durichitayat.net/system-design-interview-book/
https://www.geeksforgeeks.org/architecture-of-apache-cassandra/
https://levelup.gitconnected.com/7-algorithms-to-know-before-your-next-system-design-interview-d1de2f374ffa
