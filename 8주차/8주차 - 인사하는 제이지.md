# 15장 구글 드라이브 설계
## 문제 이해 및 개략적 설계
### 기능적 요구사항
* 파일 추가
* 파일 다운로드
* 여러 단말 파일 동기화
* 파일 갱신 이력 조회
* 파일 공유
* 알림 기능
### 비기능적 요구사항
* 안정성
* 빠른 동기화 속도
* 네트워크 대역폭
* 규모 확장성
* 높은 가용성
### 개략적 추정치
* 가입자 50,000,000, 일일 활성 사용자 10,000,000
* 모든 사용자에게 10GB 무료 저장공간 할당
* 매일 각 사용자가 평균 2개의 파일 업로드, 각 파일 평균 크기 500KB
* 읽기/쓰기 비율 1:1
* 필요한 저장공간 총량 50,000,000 * 10GB 500PB
* 업로드 API QPS = 10,000,000 * 2회 / 24시간 / 3600s = 약 240

## 개략적 설계안
### API
* 파일 업로드 API
  * 단순 업로드
    * 파일 크기가 작을 경우 한번에 업로드
  * 이어서 올리기
    * 이어 올리기 URL을 받기 위한 최초 요청 전송
    * 업로드 상태 모니터링
    * 장애 시점부터 업로드 재시작
* 파일 다운로드 API
* 파일 갱신 히스토리 조회 API
* 모든 API는 사용자 인증과 SSL 필수
### 한 대 서버 제약 극복
* 파일 용량이 부족할 경우를 대비하여 샤딩 필요
* 장애를 대비해서 다중화 필요
* S3와 같은 상용 클라우드 서비스를 이용하는게 좋음
#### 서버 가용성 높이기
* 로드밸런서와 웹서버 다중화
* 메타데이터 DB 다중화 및 샤딩
* 파일 저장소 리전 이중화
### 동기화 충돌
* 가장 단순한 방법은 낙관적 락으로 나중에 들어온 요청을 실패시키는 것
* 서버에 적용된 버전과 갱신 실패한 유저의 로컬 버전을 어떤 전략으로 처리할 것인가?
  * 합칠 것인가? 어느 한 쪽을 덮어쓸 것인가?
### 종합 구성
* 블록 저장소 서버
  * 파일 블록을 클라우드 저장소에 업로드하는 서버.
  * 파일을 블록 단위로 나눠서 저장함
  * 블록 여러개가 모여서 하나의 파일을 이루게 됨
  * 블록 하나당 해시값을 메타데이터 DB에 저장함
* 클라우드 저장소
* 아카이빙 저장소
  * 오랫동안 사용되지 않는 비활성 데이터를 보관하는 저장소
* 로드밸런서
* API 서버
* 메타데이터 DB
* 메타데이터 캐시
* 알림 서비스
  * 특정 이벤트가 발생했음을 사용자에게 알리는데 사용하는 pub-sub 시스템
  * 클라이언트에게 파일이 추가되었거나, 편집되었거나, 삭제되었음을 알림
* 오프라인 사용자 백업큐
  * 클라이언트가 접속 중이 아닐 경우 관련 이벤트 정보들을 보관했다가 나중에 사용자가 접속했을때 꺼내서 처리하기 위함
  * 근데 그렇다면 클라이언트별로 큐를 둬서 관리한다는 건데 메시징 큐가 못버틸 것 같다.
## 상세 설계
### 블록 저장소 서버
* 업데이트가 발생할때마다 전체 파일을 서버로 보내면 네트워크 대역폭에서 비효율 발새함
* 델타 동기화
  * 파일이 수정되면 수정된 블록만 갱신
  * 그렇다면 파일 각 블록들끼리 서로 의존되지 않는 구조의 파일이어야 할 듯
* 압축
  * 블록 단위로 압축해두면 데이터 크기를 많이 줄일 수 있음
  * 압축 알고리즘은 파일 유형에 따라 다르게 사용하는게 효율적임
### 높은 일관성 요구사항
* 서비스 특성상 강한 일관성이 요구됨
  * 단말이나 사용자에 따라 파일이 다른 버전으로 보여서는 안 됨
* 메모리 캐시에 최종 일관성 모델을 지원해야 함
  * 캐시에 보관된 사본이 DB의 원본과 일치해야 함
  * DB 원본이 갱신되면 바로 캐시를 evict해야 함
  * 관계형 DB가 ACID로 강한 일관성을 기본적으로 보장하므로 사용하기 용이함
### 메타데이터 DB
* 낙관적 lock을 고려해서 version 필드 필요
### 업로드 절차
#### 메타데이터 추가
* 메타데이터 생성 API 요청
* DB에 저장하고 업로드 상태를 pending으로 둠
* 유저에게 알림
#### 파일 업로드
* 파일 블록 저장소에 업로드
* 클라우드 저장소에 블록 단위로 압축, 암호화해서 업로드
* 업로드 완료시 클라우드 저장소에서 완료 콜백을 API로 호출
* 메타데이터 DB의 업로드 상태가 완료로 변경됨
* 유저에게 알림
### 다운로드 절차
* 파일 갱신 이벤트 발생시 클라이언트가 접속 중이면 새 버전을 다운로드해야 한다는 알림이 전달됨
* 클라이언트가 접속 중이지 않으면 캐싱되어 있다가 접속했을때 전달되어야 함
### 알림 서비스
#### 구현 방식
* long pooling
  * 주로 많이 씀
  * 채팅시스템과 달리 양방향 통신이 필요없기 때문
* web socket: 양방향 통신
  * 채팅 시스템처럼 그렇게 많은 메시지를 단시간에 보낼 일이 없음
* 각 클라이언트는 알림 서버와 롱 폴링을 유지하다가 특정 파일에 변경을 감지하면 연결을 끊고 동기화작업을 수행한다. 이후 작업이 완료되거나 타임아웃이 발생하면 롱 폴링 연결을 유지한다.
### 저장소 공간 절약
#### 중복 제거
* 중복된 블록을 제거한다.
#### 지능적 백업 전략
* 파일 버전 개수에 상한을 두고 나중 버전을 제거한다.
* 중요한 버전만 보관
#### 아카이빙 서버
* 자주 사용되지 않는 데이터는 아카이빙 서버에서 관리
* AWS glacier가 s3보다 이런 용도에 더 적합하고 저렴함
### 장애 처리
* 다중화와 백업, 리전 이중화를 잘 해둬야 함
* 알림 서비스는 굉장히 많은 롱 폴링을 관리하고 있기 때문에 장애가 나면 복구가 더디기 때문에 유의해야 함
## 마무리
### 블록 저장소 서버를 거치지 않고 바로 클라우드 서버에 저장한다면?
* 분할, 압축, 암호화 로직을 클라이언트 쪽에 둬야해서 단말마다 구현해야 함
* 클라이언트는 언제나 해킹 가능성이 있음
### 알림 서비스 독립

# 16장 배움은 계속된다
* 책에서 다룬 설계와 관련된 다른 회사 설계 자료 링크들이 모여 있음
* 이 중에 좀 더 관심있는 분야가 있다면 추후에 공부해보면 좋을 듯