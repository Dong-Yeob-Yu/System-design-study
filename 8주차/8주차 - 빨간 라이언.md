# 구글 드라이버 설계

### 개략적 추정치

- 사용자는 5000만명, DAU = 1000만명
- 모든 사용자에게 10GB의 무료 저장공간 할당
- 매일 각 사용자가 평균 2개의 파일을 업로드한다고 가정. 각 파일의 평균 크기는 500KB
- 읽기:쓰기 비율은 1:1
- 필요한 저장공간 = 5000만 사용자 x 10GB = 500페타바이트
- 업로드 API QPS = 1000만 사용자 x 2회 업로드 / 24시간 / 3600초 = 약 240
- 최대 QPS = 240 x 2 ⇒ 480

## 계략적 설계안 제시 및 동의

- 웹 서버를 한 대로 시작한다
    - 파일을 올리고 다운로드 하는 과정을 가진 웹 서버
    - 사용자 데이터, 로그인 정보, 파일 정보 등의 메타데이터를 보관할 DB
    - 파일을 저장할 저장소 시스템, 파일 저장을 위해 1TB의 공간을 사용할 것
- API
    1. 파일 업로드 API
        1. 단순 업로드 : 파일 사이즈가 작을때
        2. 이어 올리기 : 파일 사이즈가 크고 네트워크 문제로 업로드가 중단될 가능성이 높다고 생각되면 사용
            1. 이어 올리기 URL을 받기 위한 최초 요청 전송
            2. 데이터를 업로드하고 업로드 상태 모니터링
            3. 업로드에 장애가 발생하면 장애 발생시점부터 업로드를 재시작
    2. 파일 다운로드 API
    3. 파일 갱신 히스토리 API

### 서버 한대의 제약 극복

- 업로드 되는 파일이 많아지면 결국 파일 시스템은 가득 차게 된다. 긴급하게 생각할 수 있는 해결책으론 데이터를 샤딩하여 여러 서버에 저장하는 것이다. 하지만 이 방법은 서버에 장애가 생기면 해당 샤딩된 서버에 장애가 난다면 데이터가 유실 될 가능성이 있다. 해결책으론 S3같은 외부 저장소를 사용한다. S3는 동일 지역 내 다중화도 가능하고 여러 지역에 걸쳐 다중화도 가능하다.

![](https://image.inblog.dev/?url=https%3A%2F%2Fwww.notion.so%2Fimage%2Fhttps%253A%252F%252Fprod-files-secure.s3.us-west-2.amazonaws.com%252Ff02ca0c9-9279-4cd3-bf61-49a4adc12473%252F102cec59-63c5-40f5-b0c7-19486958ddff%252F%2525E1%252584%252580%2525E1%252585%2525B3%2525E1%252584%252585%2525E1%252585%2525B5%2525E1%252586%2525B715-7.png%3Ftable%3Dblock%26id%3Df132fda5-497b-44fb-a60d-6bb10849643c%26cache%3Dv2&w=2048&q=75)

- 로드밸런서 : 네트워크 트래픽을 분산하기 위한 로드밸런서, 혹여나 특정 웹 서버에 장애가 난다면 자동으로 해당 서버를 우회
- 웹 서버 : 로드밸런서를 추가하고 나면 많은 웹 서버를 손쉽게 추가할 수 있다.
- 메타데이터 DB : DB를 파일 저장 서버에서 분리하여 SPOF를 회피한다. 아울러 다중화 및 샤딩 정책을 적용하여 가용성, 규모 확장성 요구사항에 대응한다.
- 파일 저장소 : S3를 파일 저장소로 사용하고 가용성과 데이터 무손실을 보장하기 위해 두 개 이상의 지역에 데이터를 다중화 한다.

### 동기화 충돌

- 둘 이상의 사용자가 하나의 파일이나 폴더를 동시에 업데이트 한다면 동기화 충돌 문제가 발생할 것이다. 이 경우 먼저 시도한 사람은 변경에 성공, 뒤늦게 시도한 사람은 충돌이 발생한 것으로 표시한다.
- 이때 뒤늦게 시도한 사람의 오류는 어떻게 해결할까? → 오류가 발생한 시점에 이 시스템에 있는 같은 파일의 두 가지 버전이 존재하게 된다. 즉, 사용자2가 가지고 있는 로컬 사본과 서버에 있는 최신 버전이 그것이다. 이 상태에서 사용자는 두 파일을 하나로 합칠지 아니면 둘 중 하나를 다른 파일로 대체할지를 결정해야한다.

## 상세 설계

![](https://image.inblog.dev/?url=https%3A%2F%2Fwww.notion.so%2Fimage%2Fhttps%253A%252F%252Fprod-files-secure.s3.us-west-2.amazonaws.com%252Ff02ca0c9-9279-4cd3-bf61-49a4adc12473%252F5a4aaf98-c876-4d9d-886d-bd7e10b893e6%252F%2525E1%252584%252580%2525E1%252585%2525B3%2525E1%252584%252585%2525E1%252585%2525B5%2525E1%252586%2525B715-10.png%3Ftable%3Dblock%26id%3Dcc2fa435-ce7e-4af6-96ee-9ad15fc57966%26cache%3Dv2&w=2048&q=75)

### 블록 저장소 서버

- 정기적으로 갱신되는 큰 파일들은 업데이트가 일어날 때마다 전체 파일을 서버로 보내면 네트워크 대역폭을 많이 잡아먹게 된다. 이를 최적화 하는 방법은 2가지 정도가 있다.
    1. 델타 동기화 : 파일이 수정되면 전체 파일 대신 수정이 일어난 블록만 동기화하는 것이다.
    2. 압축 : 블록 단위로 압축해 두면 데이터 크기를 많이 줄일 수 있다. 이때 압축 알고리즘은 파일 유형에 따라 정한다.
- 이 시스템에서 블록 저장소 서버는 파일 업로드에 관계된 힘든 일을 처리하는 컴포넌트다. 파일을 블록 단위로 나눠야하고 각 블록에 압축 알고리즘을 적용, 암호화까지 해야한다. 아울러 전체 파일을 저장소 시스템으로 보내는 대신 수정된 블록만 전송해야 한다.

### 높은 일관성 요구사항

- 이 시스템은 강한 일관성 모델을 기본으로 지원해야한다. 같은 파일이 단말이나 사용자에 따라 다르게 보이는것을 허용할 수 없다는 뜻이다. 메타데이터 캐시와 DB 계층에도 같은 원칙이 적용되어야 한다.
    - 캐시에 보관된 사본과 DB에 있는 원본이 일치한다.
    - DB에 보관된 원본에 변경이 발생하면 캐시에 있는 사본을 무효화한다.
- 관계형 DB는 ACID를 보장하므로 강한 일관성을 보장하기 쉽다. 하지만 NoSQL DB는 이를 기본으로 지원하지 않으므로 동기화 로직 안에 프로그램해 넣어야 한다.

### 메타 데이터 DB

![](https://image.inblog.dev/?url=https%3A%2F%2Fwww.notion.so%2Fimage%2Fhttps%253A%252F%252Fprod-files-secure.s3.us-west-2.amazonaws.com%252Ff02ca0c9-9279-4cd3-bf61-49a4adc12473%252F0af4d57e-f567-4187-9d4c-b525ff1f9ec0%252F%2525E1%252584%252580%2525E1%252585%2525B3%2525E1%252584%252585%2525E1%252585%2525B5%2525E1%252586%2525B715-13.png%3Ftable%3Dblock%26id%3D9574ed4e-966c-422f-98c5-eb70bc51d3cf%26cache%3Dv2&w=2048&q=75)

### 업로드 절차

![](https://image.inblog.dev/?url=https%3A%2F%2Fwww.notion.so%2Fimage%2Fhttps%253A%252F%252Fprod-files-secure.s3.us-west-2.amazonaws.com%252Ff02ca0c9-9279-4cd3-bf61-49a4adc12473%252Fc96451ce-b32e-4ac0-9d33-b9535dc2b868%252F%2525E1%252584%252580%2525E1%252585%2525B3%2525E1%252584%252585%2525E1%252585%2525B5%2525E1%252586%2525B715-14.png%3Ftable%3Dblock%26id%3D682e872f-0188-46ae-aab5-c1dc042392ec%26cache%3Dv2&w=2048&q=75)

- 이 그림은 두 개 요청이 병렬적으로 전송된 상황을 보여준다. 첫 번째 요청은 파일 메타데이터를 추가하기 위한 것이고, 두 번째 요청은 파일을 클라우드 저장소로 업로드하기 위한 것이다.
    - 파일 메타데이터 추가
        1. 클라이언트 1이 새 파일을 메타데이터를 추가하기 위한 요청 전송
        2. 새 파일의 메타데이터를 DB에 저장하고 업로드 상태를 대기중으로 변경
        3. 새 파일이 추가되었음을 알림 서비스에 통지
        4. 알림 서비스는 관련된 클라이언트에게 파일이 업로드 되고 있음을 알림
    - 파일을 클라우드 저장소에 업로드
        1. 클라이언트 1이 파일을 블록 저장소 서버에 업로드
        2. 블록 저장소 서버는 파일을 블록 단위로 쪼갠 다음 압축하고 압호화 → 클라우드 저장소에 전송
        3. 업로드가 끝나면 클라우드 스토리지는 완료 콜백을 호출, 이 콜백 호출은 API 서버로 전송됨
        4. 메타데이터 DB에 기록된 해당 파일의 상태를 완료로 변경
        5. 알림 서비스에 파일 업로드가 끝났음을 통지
        6. 알림 서비스는 관련된 클라이언트에게 파일 업로드가 끝났음을 알림

### 다운로드 절차

- 파일 다운로드는 파일이 새로 추가되거나 편집되면 자동으로 시작된다. 해당 정보를 감지하는 방법 2가지
    - 클라이언트 A가 접속 중이고 다른 클라이언트가 파일을 변경하면 알림 서비스가 클라이언트 A에게 변경이 발생했으니 새 버전을 끌어가야 한다고 알린다.
    - 클라이언트 A가 네트워크에 연결된 상태가 아닐 경우에는 데이터는 캐시에 보관될 것이다. 해당 클라이언트의 상태가 접속 중으로 바뀌면 그때 해당 클라이언트는 새 버전을 가져갈 것이다.

![](https://image.inblog.dev/?url=https%3A%2F%2Fwww.notion.so%2Fimage%2Fhttps%253A%252F%252Fprod-files-secure.s3.us-west-2.amazonaws.com%252Ff02ca0c9-9279-4cd3-bf61-49a4adc12473%252F640c2b4e-127c-4f1e-8606-4ce5e3589e91%252F%2525E1%252584%252580%2525E1%252585%2525B3%2525E1%252584%252585%2525E1%252585%2525B5%2525E1%252586%2525B715-15.png%3Ftable%3Dblock%26id%3D0a091b8c-30a2-4fae-999a-a74d670ddad9%26cache%3Dv2&w=2048&q=75)

1. 알림 서비스가 클라이언트 2에게 누군가 파일을 변경했음을 알림
2. 알림을 확인한 클라이언트 2는 새로운 메타데이터를 요청
3. API 서버는 메타데이터 DB에게 새 메타데이터 요청
4. API 서버에게 새 메타데이터가 반환됨
5. 클라이언트 2에게 새 메타데이터가 반환됨
6. 클라이언트 2는 새 메타데이터를 받는 즉시 블록 다운로드 요청 전송
7. 블록 저장소 서버는 클라우드 저장소에서 블록 다운로드
8. 클라우드 저장소는 블록 서버에 요청된 블록 반환
9. 블록 저장소 서버는 클라이언트에게 요청된 블록 반환. 클라이언트 2는 전송된 블록을 사용하여 파일 재구성

### 알림 서비스

- 파일의 일관성을 유지하기 위해 클라이언트는 로컬에서 파일이 수정되었음을 감지하는 순간 다른 클라이언트에 그 사실을 알려서 충돌 가능성을 줄여야 한다. 두 가지 방법이 있지만 본 설계안은 롱 폴링을 사용할 것이다.
    - 롱 폴링
    - 웹 소켓
- 채팅 서비스와 달리, 본 시스템의 경우 양방향 통신은 필요하지 않다. 서버는 파일이 변경된 사실을 클라이언트에게 알려주어야 하지만 반대 방향의 통신은 요구되지 않는다.
- 웹 소켓은 실시간 양방향 통신이 요구되는 채팅 같은 응용에 적합하다. 구글 드라이브의 경우 알림을 보낼 일은 그렇게 자주 발생하지 않으며, 알림을 보내야 하는경우에도 단시간에 많은 양의 데이터를 보낼 일은 없다.
- 롱 폴링 방안을 쓰게 되면 각 클라이언트는 알림 서버와 롱 폴링용 연결을 유지하다가 특정 파일에 대한 변경을 감지하면 해당 연결을 끊는다. 이때 클라이언트는 반드시 메타데이터 서버와 연결해 파일의 최신 내역을 다운로드 해야 한다. 해당 다운로드 작업이 끝났거나 연결 타임아웃 시간에 도달한 경우에는 즉시 새 요청을 보내어 롱 폴링 연결을 복원하고 유지해야 한다.

### 저장소 공간 절약

- 파일 갱신 이력을 보존하고 안정성을 보장하기 위해서는 파일의 여러 버전을 여러 데이터에 센터에 보관해야한다. 하지만 모든 버전을 자주 백업하면 저장용량이 빨리 소진될 것이다. 비용 절감을 위한 3가지 방법이다.
    1. 중복 제거 : 중복된 파일 블록을 계정 차원에서 제거하는 방법, 블록 간 해시 값을 비교하여 판단.
    2. 지능적 백업 전략 도입 : 한도설정(보관해야 하는 파일 버전 개수 상한 설정), 중요한 버전만 보관(편집 중인 파일 같은 경우 업데이트 될때마다 버전을 관리하면 너무 많은 버전이 생성된다. 이러한 것을 제외하고 중요한 것만 골라내야한다.)
    3. 자주 쓰이지 않는 데이터는 아카이빙 저장소로 옮긴다. 몇달 혹은 수년간 이용되지 않는 데이터가 이에 해당한다.

### 장애 처리

- 로드밸런서 장애 : 로드 밸런서에 장애가 발생할 경우 부 로드밸런서가 활성화되어 트래픽을 이어받아야 한다. 로드 밸런서끼리는 박동(heartbeart) 신호를 주기적으로 보내서 상태를 모니터링 한다.
- 블록 저장소 서버 장애 : 블록 저장소 서버에 장애가 발생하였다면 다른 서버가 미완료 상태 또는 대기 상태인 작업을 이어받아야한다.
- 클라우드 저장소 장애 : S3버킷은 여러 지역에 다중화 할 수 있으므로, 한 지역에서 장애가 발생하면 다른 지역에서 파일을 가져온다.
- API 서버 장애 : API 서버들은 무상태 서버다. 따라서 로드밸런서는 API 서버에 장애가 발생하면 트래픽을 해당 서버로 보내지 않음으로 장애 서버를 격리한다.
- 메타데이터 캐시 장애 : 메타데이터 캐시 서버도 다중화한다. 따라서 한 노드에서 장애가 발생하면 다른 노드에서 데이터를 가져오면 된다.
- 메타데이터 DB 장애
    - 주 DB 장애 : 부 DB 서버 가운데 하나를 주 DB로 바꾸고 부 DB 서버를 새로 하나 추가한다.
    - 부 DB 장애 : 다른 부 DB 서버가 읽기 연산을 처리하도록 하고 그동안 장애 서버는 새 것으로 교체한다.
- 알림 서비스 장애 : 접속 중인 모든 사용자는 알림 서버와 롱 폴링 연결을 하나씩 유지한다. 따라서 알림 서비스는 많은 사용자아와의 연결을 유지하고 관리해야한다. 주의할것은 한 대 서버로 백만 개 이상의 접속을 유지하는것은 가능하지만, 동시에 백만 개 접속을 시작하는것은 불가능하다. 따라서 롱 폴링 연결을 복구하는 것은 상대적으로 느릴 수 있다.
- 오프라인 사용자 백업 큐 장애 : 이 큐 또한 다중화해 두어야한다. 큐에 장애가 발생하면 구독 중인 클라이언트들은 백업 큐로 구독 관계를 재설정해야한다.